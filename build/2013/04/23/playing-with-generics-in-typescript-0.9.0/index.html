<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Asap:ital,wght@0,100..900;1,100..900&family=IBM+Plex+Mono:ital,wght@0,400;0,600&family=Petrona:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">

  <!-- Tell mobile browsers we're optimized for them and they don't need to
       crop the viewport. -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/rss.xml" />
  <link rel="alternate" type="application/atom+xml" title="Atom 1.0" href="/atom.xml" />

  <!-- Styles -->
  <link rel="stylesheet" href="/style.css" type="text/css" />

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  <link rel="shortcut icon" href="/favicon.ico" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
  <link rel="manifest" href="/site.webmanifest" />

  <title>
    Playing with Generics in TypeScript 0.9.0 &ndash; journal.stuffwithstuff.com
  </title>

  <script src="/aside.js"></script>
</head>  <body>
    <main>
<header>
  <a href="/">journal.stuffwithstuff.com</a>
  <a class="about" href="#footer">↓ about me</a>
</header>
<div class="post-thread">
    <div>
      <a href="/2013/04/17/well-done/"
         title="Older Post &ldquo;Well Done: A Sentinel Value&rdquo;">&lt; prev</a>
    </div>
  <div>
    <a href="/archive">archive</a>
  </div>
    <div>
      <a href="/2013/07/18/javascript-isnt-scheme/"
         title="Newer Post &ldquo;JavaScript Isn&rsquo;t Scheme&rdquo;">next &gt;</a>
    </div>
</div>
<article>
<h1>
  <a href="/2013/04/23/playing-with-generics-in-typescript-0.9.0/" rel="bookmark"
     title="Permanent Link to Playing with Generics in TypeScript 0.9.0">
    Playing with Generics in TypeScript 0.9.0
  </a>
</h1>
<nav>
  <div class="date">
    <span class="thread-narrow"><a href="/2013/04/17/well-done/"
       title="Older Post &ldquo;Well Done: A Sentinel Value&rdquo;">&lt;</a></span>
    <a href="/archive">april 23, 2013</a>
    <span class="thread-narrow"><a href="/2013/07/18/javascript-isnt-scheme/"
       title="Newer Post &ldquo;JavaScript Isn&rsquo;t Scheme&rdquo;">&gt;</a></span>
  </div>
  <div class="tags">
      <a href="/category/dart">dart</a>
     |
      <a href="/category/language">language</a>
     |
      <a href="/category/typescript">typescript</a>
      </div>
</nav>
<div class="update">
<p>Oops! I got a bunch of this wrong because <code>Base</code> and <code>Derived</code> have no members. Since TypeScript is structurally typed, that&rsquo;s what allows all of the variance I describe below.</p>
<p>Anders Hejlsberg (!) commented on my post:</p>
<blockquote>
<p>In general, our type system is structural and generics are co-variant—but
since parameters are naturally contra-variant, in aggregate they end up being
bi-variant, as you’ve discovered. In your examples, <code>Box&lt;Base&gt;</code> and
<code>Box&lt;Derived&gt;</code> are interchangeable because they’re structurally equivalent
(they have the same set of members, namely none). If you add a member to
<code>Derived</code>, you’ll notice that <code>Box&lt;Base&gt;</code> is no longer assignable to
<code>Box&lt;Derived&gt;</code>.</p>
<p>TypeScript&rsquo;s view of classes is that they&rsquo;re just declarations of a named
interface and a constructor function, and the named interface is compatible
with any other interface that has the same set of members. What’s interesting
is our treatment of private members. Private members are inherited, but are
compatible only with themselves. If you add a private member to Base, then
only interfaces derived from Base can be compatible because only those
interfaces would have Base’s private member. Thus, private members become
“brands” that limit you to a particular branch of a hierarchy. This makes
sense because when a class has only public members, you could potentially
override every member—so it’s no different from interface. But when a private
member is introduced, the substitution principle would break down unless you
ensure every subtype has that exact private member.</p>
<p>Fun stuff!</p>
</blockquote></div>
<p>This was just going to be a comment on <a href="http://www.reddit.com/r/programming/comments/1cyij4/typescript_09_early_previews_with_support_for/">this reddit thread</a>, but then it
seemed to take on a life of its own, so I figured I may as well <s>milk it for
all it&rsquo;s worth</s> make a nice post out of it.</p>
<p>Yesterday, the TypeScript guys <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-0-9/">announced a preview of the new 0.9.0
version</a> of the language featuring generics. I, like a lot of people, was
really curious to see what approach they&rsquo;d take with them. Retrofitting a type
system onto a dynamic language is <em>hard</em> and generics are one of the places
where that new suit of armor can really chafe the squishy flesh underneath.</p>
<p>This is a topic strangely near to my heart for another reason too. I&rsquo;m on the
<a href="http://www.dart.dev">Dart team</a> and when Dart was announced, we were widely criticized for its
type system. Generics are covariant in Dart, which is a mortal sin to many.</p>
<p>Now when any new type system comes out, my first thought is, &ldquo;I wonder if it&rsquo;s
got covariant generics?&rdquo; (My second thought is, &ldquo;God, I need a hobby that
doesn&rsquo;t involve programming languages.&rdquo;)</p>
<p>Some more caveats before I get going:</p>
<ul>
<li>
<p>I literally spent five minutes poking at this, so I may have things wrong.</p>
</li>
<li>
<p>Compiling programs with a compiler that isn&rsquo;t 1.0 yet and claiming that says
something about the language specification is asking for trouble.</p>
</li>
<li>
<p>I, despite my current occupation, am surprisingly bad at reading language
specs.</p>
</li>
<li>
<p>I am currently drinking a <a href="http://www.ratebeer.com/beer/elysian-bete-blanche-belgian-tripel-2011-and-later/138973/">fairly strong beer</a>.</p>
</li>
</ul>
<p>OK, party time! After playing around with it a bit, as far as I can tell, <em>TypeScript&rsquo;s subtype relations are more permissive than I expected</em>. This isn&rsquo;t necessarily bad, just surprising. As a preamble, let&rsquo;s define a supertype and subtype:</p>
<pre class="highlight language-dart"><span class="k">class</span> <span class="t">Base</span> <span class="p">{}</span>
<span class="k">class</span> <span class="t">Derived</span> <span class="k">extends</span> <span class="t">Base</span> <span class="p">{}</span></pre>
<p>Now consider:</p>
<pre class="highlight language-dart"><span class="k">class</span> <span class="t">Box</span><span class="o">&lt;</span><span class="t">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="i">constructor</span><span class="p">(</span><span class="i">public</span> <span class="i">value</span><span class="p">:</span> <span class="t">T</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span></pre>
<p>This is the simplest possible generic type.</p>
<pre class="highlight language-dart"><span class="k">var</span> <span class="i">a</span> <span class="p">:</span> <span class="t">Box</span><span class="o">&lt;</span><span class="t">Base</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">new</span> <span class="t">Box</span><span class="o">&lt;</span><span class="t">Base</span><span class="o">&gt;</span><span class="p">(</span><span class="k">null</span><span class="p">);</span>
<span class="k">var</span> <span class="i">b</span> <span class="p">:</span> <span class="t">Box</span><span class="o">&lt;</span><span class="t">Derived</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">new</span> <span class="t">Box</span><span class="o">&lt;</span><span class="t">Derived</span><span class="o">&gt;</span><span class="p">(</span><span class="k">null</span><span class="p">);</span></pre>
<p>These are both fine, as you would expect.</p>
<pre class="highlight language-dart"><span class="k">new</span> <span class="t">Box</span><span class="o">&lt;</span><span class="i">number</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;not num&quot;</span><span class="p">)</span></pre>
<p>This gives:</p>
<pre class="highlight language-text">&#47;generics.ts(5,0): error TS2081: Supplied parameters do not match
any signature of call target.
&#47;generics.ts(5,0): error TS2085: Could not select overload for
&#39;new&#39; expression.</pre>
<p>Looks about right. Now let&rsquo;s try covariance:</p>
<pre class="highlight language-dart"><span class="k">var</span> <span class="i">c</span> <span class="p">:</span> <span class="t">Box</span><span class="o">&lt;</span><span class="t">Base</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">new</span> <span class="t">Box</span><span class="o">&lt;</span><span class="t">Derived</span><span class="o">&gt;</span><span class="p">(</span><span class="k">null</span><span class="p">);</span></pre>
<p>No errors. Contravariance?</p>
<pre class="highlight language-dart"><span class="k">var</span> <span class="i">d</span> <span class="p">:</span> <span class="t">Box</span><span class="o">&lt;</span><span class="t">Derived</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">new</span> <span class="t">Box</span><span class="o">&lt;</span><span class="t">Base</span><span class="o">&gt;</span><span class="p">(</span><span class="k">null</span><span class="p">);</span></pre>
<p>Still no errors. This, I think, makes its type system looser than arrays in
Java, and more permissive than Dart. Generics are <em>bi</em>variant in TypeScript.</p>
<pre class="highlight language-dart"><span class="k">var</span> <span class="i">e</span> <span class="p">:</span> <span class="t">Box</span><span class="o">&lt;</span><span class="i">number</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">new</span> <span class="t">Box</span><span class="o">&lt;</span><span class="t">string</span><span class="o">&gt;</span><span class="p">(</span><span class="k">null</span><span class="p">);</span></pre>
<p>As a sanity check, this <em>does</em> give an error.</p>
<pre class="highlight language-text">&#47;generics.ts(73,4): error TS2012: Cannot convert &#39;Box&lt;string&gt;&#39; to
&#39;Box&lt;number&gt;&#39;: Types of property &#39;value&#39; of types &#39;Box&lt;string&gt;&#39; and
&#39;Box&lt;number&gt;&#39; are incompatible.</pre>
<p>So it doesn&rsquo;t just <em>ignore</em> the type parameters, it really is bivariant: it will
allow either a subtype or supertype relation for the type parameters, but not no
relation at all.</p>
<p>Part of this may be because TypeScript&rsquo;s type system is structural (neat!). For
example:</p>
<pre class="highlight language-dart"><span class="k">class</span> <span class="t">A</span> <span class="p">{</span>
  <span class="i">foo</span><span class="p">(</span><span class="i">arg</span> <span class="p">:</span> <span class="t">Base</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="t">B</span> <span class="p">{</span>
  <span class="i">foo</span><span class="p">(</span><span class="i">arg</span> <span class="p">:</span> <span class="t">Derived</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span></pre>
<p>Here we have two unrelated types that happen to have the same shape (method
names and signatures). Perhaps surprisingly, there&rsquo;s no error here:</p>
<pre class="highlight language-dart"><span class="k">var</span> <span class="i">f</span> <span class="p">:</span> <span class="t">A</span> <span class="o">=</span> <span class="k">new</span> <span class="t">B</span><span class="p">();</span>
<span class="k">var</span> <span class="i">g</span> <span class="p">:</span> <span class="t">B</span> <span class="o">=</span> <span class="k">new</span> <span class="t">A</span><span class="p">();</span></pre>
<p>This is perhaps extra surprising because <code>A</code> and <code>B</code> don&rsquo;t have the <em>exact</em> same
signatures: their parameter types for <code>arg</code> are different. So the type system is
both structural and allows either supertype or subtypes on parameters.</p>
<p>If the type system is structural, maybe the <code>Box&lt;T&gt;</code> examples only worked then
because it had no methods (aside from the <code>value</code> property) that used the type
parameter. What if we make sure <code>T</code> shows up in parameter and return positions?</p>
<pre class="highlight language-dart"><span class="k">class</span> <span class="t">Box</span><span class="o">&lt;</span><span class="t">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="i">constructor</span><span class="p">(</span><span class="i">public</span> <span class="i">value</span><span class="p">:</span> <span class="t">T</span><span class="p">)</span> <span class="p">{}</span>
  <span class="i">takeParam</span><span class="p">(</span><span class="i">arg</span><span class="p">:</span> <span class="t">T</span><span class="p">)</span> <span class="p">{}</span>
  <span class="i">returnType</span><span class="p">():</span> <span class="t">T</span> <span class="p">{</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span></pre>
<p>Nope, this makes no difference. Still same behavior as before.</p>
<p>I believe the relevant bits of the spec are:</p>
<blockquote>
<p><strong>3.6.2.1 Type Arguments</strong></p>
<p>A type reference to a generic type G designates a type wherein all
occurrences of G’s type parameters have been replaced with the actual type
arguments supplied in the type reference.</p>
</blockquote>
<p>I think this basically says that generics are structurally typed and the type
relation is determined based on the <em>expanded</em> type where type arguments have
been applied. In other words, generic types don&rsquo;t have type relations, just
generic type <em>applications</em>. For example:</p>
<pre class="highlight language-dart"><span class="k">class</span> <span class="t">Generic</span><span class="o">&lt;</span><span class="t">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="i">method</span><span class="p">(</span><span class="i">arg</span><span class="p">:</span> <span class="t">T</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="t">NotGeneric</span> <span class="p">{</span>
  <span class="i">method</span><span class="p">(</span><span class="i">arg</span><span class="p">:</span> <span class="i">number</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">var</span> <span class="i">h</span> <span class="p">:</span> <span class="t">NotGeneric</span> <span class="o">=</span> <span class="k">new</span> <span class="t">Generic</span><span class="o">&lt;</span><span class="i">number</span><span class="o">&gt;</span><span class="p">();</span></pre>
<p>This is fine in TypeScript unlike most nominally-typed languages. Pretty neat!</p>
<blockquote>
<p><strong>3.8.2 Subtypes and Supertypes</strong></p>
<p>S is a subtype of a type T, and T is a supertype of S, if one of the
following is true:</p>
<ul>
<li>
<p>S’ and T are object types and, for each member M in T, one of the
following is true:</p>
<ul>
<li>
<p>M is a non-specialized call or construct signature and S’ contains a
call or construct signature N where, when substituting ‘Object’ for
all type parameters declared by M and N (if any),</p>
<ul>
<li>
<p>for parameter positions that are present in both signatures,
<strong>each parameter type in N is a subtype or supertype of the
corresponding parameter type in M</strong>,</p>
</li>
<li>
<p>the result type of M is Void, or the result type of N is a
subtype of that of M</p>
</li>
<li>
<p>&hellip;</p>
</li>
</ul>
</li>
<li>
<p>&hellip;</p>
</li>
</ul>
</li>
<li>
<p>&hellip;</p>
</li>
</ul>
</blockquote>
<p>My emphasis added. I believe this basically says that to compare two types, you
walk their members and compare their types. For method parameters, &ldquo;subtype or
supertype&rdquo; means bivariance: types go both ways. This is looser than the normal
function typing rule which is contravariance for parameters and covariance for
returns.</p>
<p>All in all, I find this pretty interesting. TypeScript has both a structural and
prototypal type system, so it&rsquo;s already pretty fascinating from a language
design perspective. Allowing bivariance of parameter types is a pretty bold
extension of that.</p>
<p>Oh, if you&rsquo;d like to see this for yourself, here&rsquo;s how:</p>
<pre class="highlight language-text">$ git clone https:&#47;&#47;git01.codeplex.com&#47;typescript
$ cd typescript
$ git checkout develop
$ jake local
$ chmod +x bin&#47;tsc</pre>
<p>Then you can run <code>bin/tsc</code> to compile stuff with the bleeding edge compiler. The
latest spec is under <code>doc/TypeScript Language Specification.pdf</code>.</p>
<div class="comments">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
      var disqus_shortname = 'journal-stuffwithstuff';
      var disqus_url = "https://journal.stuffwithstuff.com/2013/04/23/playing-with-generics-in-typescript-0.9.0/";

      (function() {
          var dsq = document.createElement('script');
          dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</article>
<footer id="footer">
  <figure>
  <a href="/"><img src="/image/dogshot_square.jpg"></a>
  </figure>
  <p>Hi! I'm Bob Nystrom. (I'm the one with glasses, not the
    <a href="/2022/02/13/stupid-dog/">dog</a>.) I wrote <a href="https://gameprogrammingpatterns.com/">Game Programming Patterns</a> and
    <a href="https://craftinginterpreters.com">Crafting Interpreters</a>. I
    make electronic music under the name
    <a href="https://tinywir.es/">Tiny Wires</a>.</p>
  <p>I'm on <a href="https://mastodon.social/@munificent">Mastodon</a> and <a href="https://bsky.app/profile/stuffwithstuff.com">Bluesky</a>, or you can email me at <code>robert</code> at this site.</p>
  <p>I built this blog using a bespoke static site generator and wrote every single word myself. The source repo
  is <a href="https://github.com/munificent/journal">here</a>.</p>
  <div class="nav-second">
  </div>
  <p class="copyright">&copy; 2008-2025 Bob Nystrom</p>
</footer>
    </main>
  </body>
 </html>
