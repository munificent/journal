<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link href='http://fonts.googleapis.com/css?family=Source+Code+Pro|PT+Serif:400,700,400italic,700italic' rel='stylesheet' type='text/css'>

    <!-- Tell mobile browsers we're optimized for them and they don't need to
         crop the viewport. -->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
    <link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/rss.xml" />
    <link rel="alternate" type="application/atom+xml" title="Atom 1.0" href="/atom.xml" />
    <link rel="stylesheet" href="/style.css" type="text/css" />

    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">

    <title>
      Multimethods, Global Scope, and Monkey-Patching
      
        &ndash; journal.stuffwithstuff.com
      
    </title>
  </head>
  <body>
    <div class="column">
      
<article>
<header>
<h1>
  <a href="/2012/06/12/multimethods-global-scope-and-monkey-patching" rel="bookmark"
     title="Permanent Link to Multimethods, Global Scope, and Monkey-Patching">
    Multimethods, Global Scope, and Monkey-Patching
  </a>
</h1>

  <a class="older" href="/2012/01/24/higher-order-macros-in-c"
     title="Older Post &ldquo;Higher Order Macros in C++&rdquo;">&#8617;</a>


  <a class="newer" href="/2012/12/19/the-impoliteness-of-overriding-methods"
     title="Newer Post &ldquo;The Impoliteness of Overriding Methods&rdquo;">&#8618;</a>

</header>
<h4><a href="/archive">June 12, 2012</a>
    <span class="tags"><a href="/category/code">code</a> <a href="/category/language">language</a> <a href="/category/magpie">magpie</a></span>
</h4>

<blockquote>
<p>What I mean is that if you really want to understand something, the best way is to try and explain it to someone else. That forces you to sort it out in your mind. And the more slow and dim-witted your pupil, the more you have to break things down into more and more simple ideas. And that&rsquo;s really the essence of programming. By the time you&rsquo;ve sorted out a complicated idea into little steps that even a stupid machine can deal with, you&rsquo;ve learned something about it yourself.</p>
</blockquote>

<p class="cite">Douglas Adams</p>

<p>I&rsquo;m interested in all kinds of languages, so I&rsquo;d read about <a href="http://journal.stuffwithstuff.com/2011/04/21/multimethods-multiple-inheritance-multiawesome/">multimethods</a> and generic functions in <a href="http://www.ravenbrook.com/doc/2003/07/15/clos-fundamentals/">Common Lisp</a>, <a href="http://clojure.org/multimethods">Clojure</a> and <a href="http://opendylan.org/">Dylan</a>. Even lesser-known languages like <a href="http://www.cs.washington.edu/research/projects/cecil/www/cecil.html">Cecil</a> and <a href="http://nice.sourceforge.net/">Nice</a>. But it wasn&rsquo;t until I <em>implemented</em> them in <a href="http://magpie-lang.org/">my own language</a> that I ran into a seemingly innocuous question: <strong>how are they scoped?</strong></p>

<p>This question consumed a great number of showers and morning commutes. I implemented a bunch of different versions and watched them break. What I finally stumbled on is really simple, but&hellip; <em>wrong-feeling</em>. This post is an explanation of how multimethods are scoped in Magpie, but also sort of a <em>rationalization</em> since the answer turns out to be &ldquo;globally&rdquo;.</p>

<p>But I&rsquo;m getting ahead of myself. First, let me rewind and set up some preliminaries. OK, maybe a <em>lot</em> of preliminaries. This is a corner of language design that I think few people wander into and previous explorers don&rsquo;t seem have left a map so maybe there will be some value in this.</p>

<h2>What Is Scope?</h2>

<p>When you hear &ldquo;scope&rdquo; you probably think something like this:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>The curly braces in C++ define <em>block scopes</em>. When you declare a local variable, it goes in the nearest enclosing scope. When the compiler sees a use of a variable (here <code>a</code>), it looks in the surrounding scopes to figure out what it&rsquo;s bound to.</p>

<p>Scopes can nest, like you see here. When a variable is defined in multiple scopes, the innermost one <em>shadows</em> the others and wins. So this program will print <code>2</code> followed by <code>1</code>.</p>

<p>Some languages like JavaScript (before <a href="http://wiki.ecmascript.org/doku.php?id=proposals:block_expressions">ES6</a>) and C (before <a href="http://stackoverflow.com/questions/1880745/c99-can-i-declare-variables-in-the-beginning-of-a-block-in-a-for">C99</a>) don&rsquo;t have block scope like this. Instead they just have <em>function scope</em>. Each function body can have its own local variables, but there are no nested scopes inside that (unless you actually nest a function in JS). You still have variables outside of functions, so you still have to think about nesting, though.</p>

<p>Both of these kinds of scope have something in common: they use <em><a href="http://c2.com/cgi/wiki?LexicalScoping">lexical scoping</a></em>. It&rsquo;s called that because you can tell what a variable name is bound to just be looking at the <em>text</em> (hence &ldquo;lexical&rdquo;) of the program. This is in contrast to <em><a href="http://en.wikipedia.org/wiki/Static_scoping#Dynamic_scoping">dynamic scoping</a></em> where you can only tell what a name is bound to at <em>runtime</em>. Lexical scoping was one of the big innovations of <a href="http://en.wikipedia.org/wiki/ALGOL">ALGOL</a>, and almost every language works like it these days.</p>

<p>This is all well and good for scoping <em>variables</em>, but for the sake of this post, I&rsquo;ll widen the term to talk about any kind of identifier that appears in a program. Variables aren&rsquo;t the only place names appear in many languages. Consider this bit of JavaScript:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="kd">function</span><span class="p">(</span><span class="nx">who</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">(</span><span class="nx">who</span><span class="p">.</span><span class="nx">favoriteColor</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Here we have two names in the program (ignoring <code>alert</code>), <code>who</code> and <code>favoriteColor</code>. We need to figure out what they represent in order to run the code. <code>who</code> is easy, it&rsquo;s just a lexically scoped variable and we can see that it&rsquo;s bound to whatever you pass to the function.</p>

<p>What&rsquo;s about <code>favoriteColor</code>? Since it comes after a <code>.</code>, that means it&rsquo;s a <em>property accessor</em>. Each object in JS carries a little bag of named properties around with it. When we do <code>.favoriteColor</code> here, it looks for a property named <code>favoriteColor</code> in that bag at runtime and returns its value. We&rsquo;ll call this <em>object scope</em>.</p>

<p>Being a <a href="http://en.wikipedia.org/wiki/Prototype-based_programming">prototype-based language</a>, JS is pretty simple here. It only has lexical scope and object scope. Class-based object-oriented languages often have a couple more scopes. Methods will be looked up on the <em>class</em> of the receiver, and there is usually a separate scope for &ldquo;static&rdquo; methods.</p>

<h2>What Scopes Does Magpie Have?</h2>

<p>OK, so we have block scope, object scope, method scope, static scope. There&rsquo;s lexical scoping and dynamic scoping. Which of these does Magpie have?</p>

<p>Just one: <em>lexical block scope.</em></p>

<p>Magpie is a <a href="http://magpie-lang.org/classes.html">class-based</a> <a href="http://magpie-lang.org/objects.html">object-oriented</a> language, and its syntax is designed to look (more or less) like one. It doesn&rsquo;t use a dot to separate the &ldquo;receiver&rdquo; from the method or property, but it otherwise looks like it <em>would</em> have object, method, and static scope:</p>
<div class="highlight"><pre><code class="language-magpie" data-lang="magpie"><span></span><span class="n">list</span> <span class="n">add</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</code></pre></div>
<p>When it&rsquo;s compiling <code>list add(item)</code>, the variables <code>list</code> and <code>item</code> are looked up in lexical scope like you expect. But the method <code>add</code> is too. In Magpie, methods are not bound to classes. Instead, they are defined separately. If you know C&rsquo;s model of &ldquo;structs + functions&rdquo;, you have roughly the right idea. If you know CLOS or Dylan, you have <em>exactly</em> the right idea.</p>

<p>When you see <code>list add(item)</code> it looks like you&rsquo;re calling <code>add</code> &ldquo;on&rdquo; some <code>list</code> object, but what it really means is &ldquo;call this <code>add</code> method, passing in <code>list</code> and <code>item</code> as arguments&rdquo;. It&rsquo;s the same as <code>add(list, item)</code> in other languages. Magpie just has a syntax that lets you stick the method name in the middle.</p>

<p>In addition, &ldquo;property accessors&rdquo; in Magpie <a href="http://en.wikipedia.org/wiki/Uniform_access_principle">are just methods too</a>. So when you see <code>person favoriteColor</code>, that&rsquo;s just <code>favoriteColor(person)</code>. To compile that, we just look up <code>favoriteColor</code> in lexical scope like you would a variable.</p>

<p>So how far up do these scopes go? In Magpie, each source file is a <a href="http://magpie-lang.org/modules.html">module</a> and each module has its own top-level scope. There is no single global shared scope. Instead, each module is its own little island that only sees the names that it defines or explicitly imports.</p>

<h2>What About Polymorphism?</h2>

<p>&ldquo;Polymorphism&rdquo; in the object-oriented sense means that the same method can do different things at runtime given different kinds of objects. &ldquo;Single-dispatch&rdquo; OOP languages, which are probably what you&rsquo;re familiar with, achieve this by treating the receiving object (i.e. <code>this</code>) as a scope. By looking up the method on the receiver at runtime, you get behavior that varies based on that object. Magpie on the other hand, just looks up the method in lexical scope.</p>

<p>If methods aren&rsquo;t looked up on the object (or on its class), how do we get polymorphism in Magpie? How can I make an <code>add()</code> method that does the right thing given a list, a set, or a map?</p>

<p>The answer is that all methods in Magpie are <a href="http://journal.stuffwithstuff.com/2011/04/21/multimethods-multiple-inheritance-multiawesome/">multimethods</a>. The <a href="http://magpie-lang.org/multimethods.html">docs</a> have the full story, but here&rsquo;s the TL;DR: You can define multiple methods with the same name but different argument <a href="http://magpie-lang.org/patterns.html">patterns</a>, like so:</p>
<div class="highlight"><pre><code class="language-magpie" data-lang="magpie"><span></span><span class="k">def</span> <span class="p">(</span><span class="n">list</span> <span class="k">is</span> <span class="n">List</span><span class="p">)</span> <span class="n">add</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="c1">// add stuff to list...</span>
<span class="k">end</span>

<span class="k">def</span> <span class="p">(</span><span class="n">set</span> <span class="k">is</span> <span class="n">Set</span><span class="p">)</span> <span class="n">add</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="c1">// add stuff to set...</span>
<span class="k">end</span>

<span class="k">def</span> <span class="p">(</span><span class="n">map</span> <span class="k">is</span> <span class="n">Map</span><span class="p">)</span> <span class="n">add</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="c1">// add stuff to map...</span>
<span class="k">end</span>
</code></pre></div>
<p>In C, this would just be an error because the names collide. In Magpie, it&rsquo;s A-OK. What this does is a create a <em>single</em> <code>add()</code> <em>multi</em>method that contains those three methods. When you call <code>add()</code>, it looks at the types of the arguments at runtime and picks the right method to call. Instead of using <em>scoping</em> for polymorphism, it essentially uses <a href="http://www.haskell.org/tutorial/patterns.html">pattern matching</a>.</p>

<h2>Time For a Snack Break</h2>

<p>That probably all sounds a bit hand-wavey. Let&rsquo;s walk through a concrete example and see how all of the moving parts mesh together. First, let&rsquo;s make a module that defines a class and some methods for it.</p>
<div class="highlight"><pre><code class="language-magpie" data-lang="magpie"><span></span><span class="c1">// sandwich.mag</span>
<span class="k">defclass</span> <span class="n">Sandwich</span>
    <span class="k">val</span> <span class="n">meat</span>
    <span class="k">val</span> <span class="n">condiment</span>
<span class="k">end</span>

<span class="k">def</span> <span class="p">(</span><span class="n">sandwich</span> <span class="k">is</span> <span class="n">Sandwich</span><span class="p">)</span> <span class="n">isVegetarian</span>
    <span class="n">sandwich</span> <span class="n">meat</span> <span class="o">==</span> <span class="s">&quot;tofu&quot;</span>
<span class="k">end</span>

<span class="k">def</span> <span class="p">(</span><span class="n">sandwich</span> <span class="k">is</span> <span class="n">Sandwich</span><span class="p">)</span> <span class="n">toString</span>
    <span class="s">&quot;A tasty &quot;</span> <span class="o">+</span> <span class="n">meat</span> <span class="o">+</span> <span class="s">&quot; and &quot;</span> <span class="o">+</span> <span class="n">condiment</span> <span class="o">+</span> <span class="s">&quot; sandwich&quot;</span>
<span class="k">end</span>
</code></pre></div>
<p>So we have a class <code>Sandwich</code>. This will also automatically give us getter methods for <code>meat</code> and <code>condiment</code> that will return the appropriate fields given a <code>Sandwich</code> instance on the left. In addition, we add another method <code>isVegetarian</code>. It takes a sandwich and returns <code>true</code> if it doesn&rsquo;t have any meat in it. Finally, we give it a <code>toString</code> method so you can print it and stuff.</p>

<p>Now let&rsquo;s make another module that uses this one:</p>
<div class="highlight"><pre><code class="language-magpie" data-lang="magpie"><span></span><span class="c1">// main.mag</span>
<span class="k">import</span> <span class="n">sandwich</span>

<span class="k">val</span> <span class="n">sandwich</span> <span class="o">=</span> <span class="n">Sandwich</span> <span class="n">new</span><span class="p">(</span><span class="n">meat</span><span class="err">:</span> <span class="s">&quot;ham&quot;</span><span class="p">,</span> <span class="n">condiment</span><span class="err">:</span> <span class="s">&quot;mayo&quot;</span><span class="p">)</span>
<span class="n">print</span><span class="p">(</span><span class="s">&quot;veggie? &quot;</span> <span class="o">+</span> <span class="n">sandwich</span> <span class="n">isVegetarian</span><span class="p">)</span>
<span class="n">print</span><span class="p">(</span><span class="n">sandwich</span><span class="p">)</span>
</code></pre></div>
<p>Seems pretty simple, right? It turns out that not binding methods to classes leads to a couple of subtle but deep problems. (At least they were subtle to <em>me</em>. I didn&rsquo;t realize them until I&rsquo;d implemented the intepreter and ran straight into them.)</p>

<p>These problems all turn out to be related exactly to the original question of this post, how methods are scoped, and solving them is what led to Magpie&rsquo;s current (and perhaps surprising) answer.</p>

<h2>The First Problem: &ldquo;Overriding&rdquo; Methods</h2>

<p>So what happens when we run this example? Let&rsquo;s say for now that methods are scoped just like variables, which is how Magpie <em>used</em> to work. We&rsquo;ll walk through it a line at a time.</p>
<div class="highlight"><pre><code class="language-magpie" data-lang="magpie"><span></span><span class="k">import</span> <span class="n">sandwich</span>
</code></pre></div>
<p>This takes all of the top-level variables and methods in <code>sandwich.mag</code> and binds them to the same names in <code>main.mag</code>. After that <code>Sandwich</code>, <code>meat</code>, <code>condiment</code>, <code>isVegetarian</code>, and <code>toString</code> are all available for use.</p>
<div class="highlight"><pre><code class="language-magpie" data-lang="magpie"><span></span><span class="k">val</span> <span class="n">sandwich</span> <span class="o">=</span> <span class="n">Sandwich</span> <span class="n">new</span><span class="p">(</span><span class="n">meat</span><span class="err">:</span> <span class="s">&quot;ham&quot;</span><span class="p">,</span> <span class="n">condiment</span><span class="err">:</span> <span class="s">&quot;mayo&quot;</span><span class="p">)</span>
</code></pre></div>
<p>This creates a new <code>Sandwich</code> instance and stores it in a variable <code>sandwich</code>.</p>
<div class="highlight"><pre><code class="language-magpie" data-lang="magpie"><span></span><span class="n">print</span><span class="p">(</span><span class="s">&quot;veggie? &quot;</span> <span class="o">+</span> <span class="n">sandwich</span> <span class="n">isVegetarian</span><span class="p">)</span>
</code></pre></div>
<p>This calls <code>isVegetarian</code>. We&rsquo;ve imported that method, so there&rsquo;s no problem here. Now consider the last line:</p>
<div class="highlight"><pre><code class="language-magpie" data-lang="magpie"><span></span><span class="n">print</span><span class="p">(</span><span class="n">sandwich</span><span class="p">)</span>
</code></pre></div>
<p><code>print()</code> is a built-in method that takes an object, converts it to a string by calling <code>toString</code> on it, and then displays it. &ldquo;Built-in&rdquo; just means it&rsquo;s defined in another <code>core</code> module and is automatically imported, so we do indeed have access to it from <code>main.mag</code>. So we call it and pass in the sandwich. What happens next?</p>

<p>What <em>doesn&rsquo;t</em> happen is that it doesn&rsquo;t call the <code>toString</code> that we actually defined for <code>Sandwich</code>. That method is scoped to <code>sandwich.mag</code>. We imported it into <code>main.mag</code> so we could call it <em>there</em>. But we aren&rsquo;t calling <code>toString</code> in <code>main.mag</code>. It&rsquo;s being called from <code>print</code>, which is in <code>core</code>. It has no idea there&rsquo;s this other <code>toString</code> method specialized for sandwiches because the <code>toString</code> multimethod <code>core</code> knows about is unrelated to the one <code>sandwich.mag</code> and <code>main.mag</code> have.</p>

<p>Ouch. Our intent in <code>sandwich.mag</code> is that defining <code>toString</code> would work like <a href="http://en.wikipedia.org/wiki/Method_overriding">overriding</a> in other OOP languages. Any place that is calling <code>toString</code> should see that new specialization even if it hasn&rsquo;t directly imported the module that contains it.</p>

<h2>The First Solution: Shared Multimethod Objects</h2>

<p>My <a href="https://groups.google.com/forum/?fromgroups#!topic/magpie-lang/BilLNpvklYQ">fix</a> for this was to change what it means to import a multimethod. In our little example, the import graph is like:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>core
  ^
  |\
  | \
  | sandwich
  |  ^
  | /
  |/
 main
</code></pre></div>
<p><code>main.mag</code> imports <code>sandwich.mag</code> and they both also (implicitly) import <code>core</code>. Core itself contains a <code>toString</code> method with specializations for the atomic types like numbers and strings.</p>

<p>The first fix was that when you import a method, you import the <em>exact same multimethod object</em>. So <code>sandwich.mag</code> imports the <code>toString</code> multimethod from <code>core</code>. When it then defines a new <code>(sandwich is Sandwich) toString</code> specialization, that goes into the <em>exact same multimethod that <code>core</code> is using</em>. There is basically a single <code>toString</code> object in memory that all of those modules have a reference to.</p>

<p>This works because <code>core</code> is the first module that created it, and our other two modules are both importing it. So every place that&rsquo;s using <code>toString</code> has a path of imports that ultimately traces back to the root in <code>core</code>.</p>

<h2>The Second Problem: Colliding Imports</h2>

<p>Problem solved, right? Well, not so fast. After I did this, I ran into the next issue. Here&rsquo;s another example. We&rsquo;ve got these two modules:</p>
<div class="highlight"><pre><code class="language-magpie" data-lang="magpie"><span></span><span class="c1">// pal.mag</span>
<span class="k">defclass</span> <span class="n">Pal</span>
    <span class="k">val</span> <span class="n">name</span>
<span class="k">end</span>

<span class="c1">// pet.mag</span>
<span class="k">defclass</span> <span class="n">Pet</span>
    <span class="k">val</span> <span class="n">name</span>
<span class="k">end</span>
</code></pre></div>
<p>They both define classes that have <code>name</code> fields. That means they both implicitly create <code>name</code> methods. Then we use them:</p>
<div class="highlight"><pre><code class="language-magpie" data-lang="magpie"><span></span><span class="c1">// main.mag</span>
<span class="k">import</span> <span class="n">Pal</span>
<span class="k">import</span> <span class="n">Pet</span>

<span class="k">def</span> <span class="n">greet</span><span class="p">(</span><span class="n">who</span><span class="p">)</span>
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;Hi, &quot;</span> <span class="o">+</span> <span class="n">who</span> <span class="n">name</span> <span class="o">+</span> <span class="s">&quot;!&quot;</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">greet</span><span class="p">(</span><span class="n">Pal</span> <span class="n">new</span><span class="p">(</span><span class="n">name</span><span class="err">:</span> <span class="s">&quot;Fred&quot;</span><span class="p">))</span>
<span class="n">greet</span><span class="p">(</span><span class="n">Pet</span> <span class="n">new</span><span class="p">(</span><span class="n">name</span><span class="err">:</span> <span class="s">&quot;Rex&quot;</span><span class="p">))</span>
</code></pre></div>
<p>The intent here is clear: <code>greet()</code> should be able to print anything that has a <code>name</code> getter. What happens if we run this with our current semantics? It turns out we don&rsquo;t get very far.</p>

<p>The <code>import Pal</code> line works fine. It brings <code>Pal</code> and <code>name</code> into <code>main.mag</code>. Then the second import comes along. It defines <code>Pet</code> fine, but there&rsquo;s already a <code>name</code> multimethod defined now. We have a name collision.</p>

<p>We didn&rsquo;t have a name collision in the first example. Even though <code>toString</code> got imported into <code>main.mag</code> both from <code>core</code> and <code>sandwich.mag</code>, they were the exact same object, so we could just safely ignore it. Here, though, that isn&rsquo;t the case. The import graph is like:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>pal  pet
 ^    ^
  \  /
   \/
  main
</code></pre></div>
<p>There is no root module where a single <code>name</code> multimethod is being created. Instead, <code>pal.mag</code> and <code>pet.mag</code> both create their own unrelated <code>name</code> multimethods. When <code>main.mag</code> tries to import them both, they aren&rsquo;t the same object, so they collide.</p>

<h2>The Second (Failed) Solution: Just Deal With It</h2>

<p>My first stab at &ldquo;fixing&rdquo; this was to just declare those semantics are How It Should Be. If you have colliding method names, you just rename on import, like:</p>
<div class="highlight"><pre><code class="language-magpie" data-lang="magpie"><span></span><span class="c1">// main.mag</span>
<span class="k">import</span> <span class="n">Pal</span> <span class="k">with</span>
    <span class="n">name</span> <span class="n">as</span> <span class="n">pal.name</span>
<span class="k">end</span>
<span class="k">import</span> <span class="n">Pet</span> <span class="k">with</span>
    <span class="n">name</span> <span class="n">as</span> <span class="n">pet.name</span>
<span class="k">end</span>
</code></pre></div>
<p>That works, but it&rsquo;s really ugly. I found in practice that method collisions were surprisingly common, almost always coming from fields with simple names like <code>name</code>. Having to qualify those at every use site sucks:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>greet(who)
    print(&quot;Hi, &quot; + who pal.name + &quot;!&quot;)
end
</code></pre></div>
<p>Worse, it breaks <a href="http://en.wikipedia.org/wiki/Duck_typing">duck typing</a>. Using this scheme, there&rsquo;s no way to create a single <code>greet()</code> method that works on both pets and pals since there isn&rsquo;t a single <code>name</code> method it can call on both.</p>

<h2>The Third (Failed) Solution: Do Something Really Complex</h2>

<p>At first, I tried to fix this by doing some hairy method merging when you imported. If you had a method name collision on import, it would create a new local multimethod object that contained all of the specializations of both of the ones you&rsquo;re importing. That fixes the above problem. <code>main.mag</code> will end up with one <code>name</code> method that can accept both pals and pets.</p>

<p>But it unfixes the <em>first</em> problem. If you import a multimethod (like <code>toString</code> in the first example) and then add a new specialization, you need to push that specialization back <em>up</em> to the modules that you imported.</p>

<p>So to get that working, I made it track where you had all of the modules you had imported a multimethod from. When you defined a new specialization, that would get pushed back up to those modules too.</p>

<p>This did sort of work, but it was complex, felt brittle, and was hard to reason about.</p>

<h2>The Fourth Solution: Go Global</h2>

<p>I spent a lot of time thinking about it and finally asked if there was a radically simpler answer that would work. One came to mind: <strong>make methods <em>globally</em> scoped.</strong></p>

<p>Any time you define a method, in <em>any</em> module, it would just go into a single global pool of multimethods that all modules share. Overriding works, because you&rsquo;re <em>always</em> overriding: there is only a single multimethod with a given name across the entire program. Duck typing works for the exact same reason.</p>

<p>But global scope is <a href="http://c2.com/cgi/wiki?GlobalVariablesAreBad">bad</a>, right? I felt like I was committing some cardinal sin by even contemplating this. After much gnashing of teeth, I concocted a rationalization for why this might not be so bad. Here goes&hellip;</p>

<p>Consider your favorite conventional OOP language. We&rsquo;ll do Ruby because it looks nice here:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="k">class</span> <span class="nc">Cow</span>
    <span class="k">def</span> <span class="nf">speak</span><span class="p">()</span>
        <span class="nb">puts</span> <span class="s2">&quot;moo&quot;</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Dog</span>
    <span class="k">def</span> <span class="nf">speak</span><span class="p">()</span>
        <span class="nb">puts</span> <span class="s2">&quot;woof&quot;</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>We have two classes that both define <code>speak</code> methods. We don&rsquo;t think of <code>speak</code> as being &ldquo;global&rdquo; here because you get to the <code>speak</code> methods <em>through</em> an instance of <code>Cow</code> or <code>Dog</code>. Once you do, the method will correctly be associated with the right type and do the right thing. You can&rsquo;t call <code>Dog</code>&lsquo;s <code>speak</code> on an instance of <code>Cow</code> or some other unrelated type. Likewise, if you don&rsquo;t have a dog or a cow, you can&rsquo;t get to <code>speak</code> at all.</p>

<p>Now consider the Magpie equivalent, and assume that multimethods are globally scoped:</p>
<div class="highlight"><pre><code class="language-magpie" data-lang="magpie"><span></span><span class="k">defclass</span> <span class="n">Cow</span>
<span class="k">end</span>

<span class="k">def</span> <span class="p">(</span><span class="k">is</span> <span class="n">Cow</span><span class="p">)</span> <span class="n">speak</span>
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;moo&quot;</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">defclass</span> <span class="n">Dog</span>
<span class="k">end</span>

<span class="k">def</span> <span class="p">(</span><span class="k">is</span> <span class="n">Dog</span><span class="p">)</span> <span class="n">speak</span>
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;woof&quot;</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<p>How does it compare? Like the Ruby solution, you can&rsquo;t call <code>Cow</code>&rsquo;s <code>speak</code> method using a <code>Dog</code> or some other type. If you don&rsquo;t have a dog or a cow, you can&rsquo;t get to <code>speak</code> at all.</p>

<p>What this means is that the <em>multi</em>method is globally scoped. But actual specializations, the stuff you care about, functionally aren&rsquo;t. Since they are specialized to types, if you don&rsquo;t have an object of that type, you can&rsquo;t get to the method. The multimethod is sitting there in global scope where anyone can get to it, but unless you have the key (an object of the right class), you can&rsquo;t crack it open and get at the methods.</p>

<p>In other words, globally scoped multimethods in Magpie are isomorphic to methods in a single dispatch language. Actually, that&rsquo;s only half true. Single-dispatch languages only support a <em>subset</em> of what multimethods let you do. Magpie can also express a bunch of stuff that single-dispatch languages can&rsquo;t.</p>

<h2>Better than Monkey-Patching</h2>

<p>Multimethods match on <em>all</em> of their arguments, not just the &ldquo;receiver&rdquo; on the left-hand side. Let&rsquo;s go back to our Ruby example. Say we need to serialize Dogs and Cows to a stream. Since classes in Ruby are open for extension, we can do:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="k">class</span> <span class="nc">Dog</span>
    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
        <span class="n">stream</span> <span class="n">write</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">)</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Cow</span>
    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
        <span class="n">stream</span> <span class="n">write</span><span class="p">(</span><span class="s2">&quot;cow&quot;</span><span class="p">)</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>Swell. But then someone else on our team gets tasked with making dogs and cows support serializing to XML. If they aren&rsquo;t aware of <em>our</em> monkey-patch and add:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="k">class</span> <span class="nc">Dog</span>
    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">xmlWriter</span><span class="p">)</span>
        <span class="n">xmlWriter</span> <span class="n">write</span><span class="p">(</span><span class="s2">&quot;&lt;dog&gt;&lt;/dog&gt;&quot;</span><span class="p">)</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Cow</span>
    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">xmlWriter</span><span class="p">)</span>
        <span class="n">xmlWriter</span> <span class="n">write</span><span class="p">(</span><span class="s2">&quot;&lt;cow&gt;&lt;/cow&gt;&quot;</span><span class="p">)</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>Then those <code>serialize</code> methods will obliterate the ones for writing to a stream. Or maybe the other way around. It depends on whose code gets to run last. Nasty.</p>

<p>Meanwhile, in Magpie:</p>
<div class="highlight"><pre><code class="language-magpie" data-lang="magpie"><span></span><span class="k">def</span> <span class="p">(</span><span class="n">dog</span> <span class="k">is</span> <span class="n">Dog</span><span class="p">)</span> <span class="n">write</span><span class="p">(</span><span class="n">stream</span> <span class="k">is</span> <span class="n">Stream</span><span class="p">)</span>
    <span class="n">stream</span> <span class="n">write</span><span class="p">(</span><span class="s">&quot;dog&quot;</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="p">(</span><span class="n">cow</span> <span class="k">is</span> <span class="n">Cow</span><span class="p">)</span> <span class="n">write</span><span class="p">(</span><span class="n">stream</span> <span class="k">is</span> <span class="n">Stream</span><span class="p">)</span>
    <span class="n">stream</span> <span class="n">write</span><span class="p">(</span><span class="s">&quot;cow&quot;</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="p">(</span><span class="n">dog</span> <span class="k">is</span> <span class="n">Dog</span><span class="p">)</span> <span class="n">write</span><span class="p">(</span><span class="n">writer</span> <span class="k">is</span> <span class="n">XmlWriter</span><span class="p">)</span>
    <span class="n">writer</span> <span class="n">write</span><span class="p">(</span><span class="s">&quot;&lt;dog&gt;&lt;/dog&gt;&quot;</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="p">(</span><span class="n">cow</span> <span class="k">is</span> <span class="n">Cow</span><span class="p">)</span> <span class="n">write</span><span class="p">(</span><span class="n">writer</span> <span class="k">is</span> <span class="n">XmlWriter</span><span class="p">)</span>
    <span class="n">writer</span> <span class="n">write</span><span class="p">(</span><span class="s">&quot;&lt;cow&gt;&lt;/cow&gt;&quot;</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<p>Here, there is no collision at all. When you call <code>write</code>, it will look at both the left-hand argument (a <code>Cow</code> or a <code>Dog</code>) <em>and</em> the right-hand side (a <code>Stream</code> or an <code>XmlWriter</code>) and pick the one perfect method for those types.</p>

<p>This means you can effectively &ldquo;monkey-patch&rdquo; with much finer-grained control and less chance of collision. The entire argument signature forms a key that&rsquo;s used to select the right method. If you don&rsquo;t want people to accidentally hit your specific method, just ensure that it requires an argument of a type that&rsquo;s hard to get a hold of.</p>

  <div class="social">
    <a href="//www.reddit.com/submit?url=http://journal.stuffwithstuff.com/2012/06/12/multimethods-global-scope-and-monkey-patching/" target="_blank">
      <i class="fa fa-lg fa-reddit-square"></i>
    </a>

    <a href="//news.ycombinator.com/submitlink?u=http://journal.stuffwithstuff.com/2012/06/12/multimethods-global-scope-and-monkey-patching/&amp;t=Multimethods, Global Scope, and Monkey-Patching" target="_blank">
      <i class="fa fa-lg fa-hacker-news"></i>
    </a>

    <a href="http://twitter.com/share?url=http://journal.stuffwithstuff.com/2012/06/12/multimethods-global-scope-and-monkey-patching&amp;text=%22Multimethods, Global Scope, and Monkey-Patching%22%20%40munificentbob" target="_blank">
      <i class="fa fa-lg fa-twitter-square"></i>
    </a>

    <a href="http://www.facebook.com/share.php?u=http://journal.stuffwithstuff.com/2012/06/12/multimethods-global-scope-and-monkey-patching" target="_blank">
      <i class="fa fa-lg fa-facebook-square"></i>
    </a>

    <a href="https://plus.google.com/share?url=http://journal.stuffwithstuff.com/2012/06/12/multimethods-global-scope-and-monkey-patching" target="_blank">
      <i class="fa fa-lg fa-google-plus-square"></i>
    </a>

    <a href="/rss.xml">
      <i class="fa fa-lg fa-rss-square"></i>
    </a>
  </div>

  
  <div class="comments">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'journal-stuffwithstuff';
        var disqus_url = "http://journal.stuffwithstuff.com/2012/06/12/multimethods-global-scope-and-monkey-patching";

        (function() {
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
  
</article>


      <nav>
  <div class="nav-first">
    <a href="/"><img src="/image/dogshot_square.jpg" class="bob"></a>

    <p>Hi! I'm <strong>Bob Nystrom</strong>, the one on the left.</p>
    <p>I wrote a book called <a href="http://gameprogrammingpatterns.com/"><strong>Game Programming Patterns</strong></a>. I'm working on another book called
    <a href="http://craftinginterpreters.com">Crafting Interpreters</a></p>
    <p>You can email me at <code>robert</code> at this site or follow me on twitter at <a href="https://twitter.com/intent/user?screen_name=munificentbob"><code>@munificentbob</code></a>.</p>

    <h2>Elsewhere</h2>
    <ul>
      <li>Code at <a href="http://github.com/munificent">github</a></li>
      <li>Tweets at <a href="http://twitter.com/munificentbob">twitter</a></li>
      <li>Photos at <a href="https://500px.com/munificent">500px</a></li>
      <li>Photos at <a href="http://www.flickr.com/photos/bobisbob/">flickr</a></li>
    </ul>
  </div>
  <div class="nav-second">
    <h2>Categories</h2>
    <ul><li><a href="/category/code">code</a> <small class='post-count'>67</small></li><li><a href="/category/language">language</a> <small class='post-count'>41</small></li><li><a href="/category/magpie">magpie</a> <small class='post-count'>24</small></li><li><a href="/category/c-sharp">c-sharp</a> <small class='post-count'>13</small></li><li><a href="/category/dart">dart</a> <small class='post-count'>13</small></li><li><a href="/category/game-dev">game-dev</a> <small class='post-count'>12</small></li><li><a href="/category/java">java</a> <small class='post-count'>10</small></li><li><a href="/category/cpp">cpp</a> <small class='post-count'>8</small></li><li><a href="/category/game-patterns">game-patterns</a> <small class='post-count'>6</small></li><li><a href="/category/parsing">parsing</a> <small class='post-count'>6</small></li><li><a href="/category/roguelike">roguelike</a> <small class='post-count'>6</small></li><li><a href="/category/design">design</a> <small class='post-count'>5</small></li><li><a href="/category/go">go</a> <small class='post-count'>5</small></li><li><a href="/category/js">js</a> <small class='post-count'>4</small></li><li><a href="/category/book">book</a> <small class='post-count'>3</small></li><li><a href="/category/c">c</a> <small class='post-count'>3</small></li><li><a href="/category/finch">finch</a> <small class='post-count'>3</small></li><li><a href="/category/python">python</a> <small class='post-count'>3</small></li><li><a href="/category/ruby">ruby</a> <small class='post-count'>3</small></li><li><a href="/category/blog">blog</a> <small class='post-count'>2</small></li><li><a href="/category/f-sharp">f-sharp</a> <small class='post-count'>2</small></li><li><a href="/category/lua">lua</a> <small class='post-count'>2</small></li><li><a href="/category/music">music</a> <small class='post-count'>2</small></li><li><a href="/category/ai">ai</a> <small class='post-count'>1</small></li><li><a href="/category/beta">beta</a> <small class='post-count'>1</small></li><li><a href="/category/blogofile">blogofile</a> <small class='post-count'>1</small></li><li><a href="/category/game">game</a> <small class='post-count'>1</small></li><li><a href="/category/jasic">jasic</a> <small class='post-count'>1</small></li><li><a href="/category/javascript">javascript</a> <small class='post-count'>1</small></li><li><a href="/category/oop">oop</a> <small class='post-count'>1</small></li><li><a href="/category/optimization">optimization</a> <small class='post-count'>1</small></li><li><a href="/category/oscon">oscon</a> <small class='post-count'>1</small></li><li><a href="/category/politics">politics</a> <small class='post-count'>1</small></li><li><a href="/category/scheme">scheme</a> <small class='post-count'>1</small></li><li><a href="/category/typescript">typescript</a> <small class='post-count'>1</small></li><li><a href="/category/visualization">visualization</a> <small class='post-count'>1</small></li></ul>

    <p class="archive">All <a href="/archive">74 articles</a>&hellip;</p>

    <p>This blog is built using <a href="http://jekyllrb.com/">jekyll</a>. The source repo for it is <a href="https://github.com/munificent/journal">here</a>.</p>
    <p class="copyright">&copy; 2008-2014 Robert Nystrom</p>
  </div>
</nav>
    </div>
  </body>
</html>
