<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Asap:ital,wght@0,100..900;1,100..900&family=IBM+Plex+Mono:ital,wght@0,400;0,600&family=Petrona:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">

  <!-- Tell mobile browsers we're optimized for them and they don't need to
       crop the viewport. -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/rss.xml" />
  <link rel="alternate" type="application/atom+xml" title="Atom 1.0" href="/atom.xml" />

  <!-- Styles -->
  <link rel="stylesheet" href="/style.css" type="text/css" />

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  <link rel="shortcut icon" href="/favicon.ico" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
  <link rel="manifest" href="/site.webmanifest" />

  <title>
    ML-Style Pattern Matching in C# &ndash; journal.stuffwithstuff.com
  </title>

  <script src="/aside.js"></script>
</head>  <body>
    <main>
<header>
  <a href="/">journal.stuffwithstuff.com</a>
  <a class="about" href="#footer">â†“ about me</a>
</header>
<div class="post-thread">
    <div>
      <a href="/2009/05/05/one-and-only-one/"
         title="Older Post &ldquo;One and Only One&rdquo;">&lt; prev</a>
    </div>
  <div>
    <a href="/archive">archive</a>
  </div>
    <div>
      <a href="/2009/05/15/loops-in-magpie/"
         title="Newer Post &ldquo;Loops in Magpie&rdquo;">next &gt;</a>
    </div>
</div>
<article>
<h1>
  <a href="/2009/05/13/ml-style-pattern-matching-in-c/" rel="bookmark"
     title="Permanent Link to ML-Style Pattern Matching in C#">
    ML-Style Pattern Matching in C#
  </a>
</h1>
<nav>
  <div class="date">
    <span class="thread-narrow"><a href="/2009/05/05/one-and-only-one/"
       title="Older Post &ldquo;One and Only One&rdquo;">&lt;</a></span>
    <a href="/archive">may 13, 2009</a>
    <span class="thread-narrow"><a href="/2009/05/15/loops-in-magpie/"
       title="Newer Post &ldquo;Loops in Magpie&rdquo;">&gt;</a></span>
  </div>
  <div class="tags">
      <a href="/category/c-sharp">c-sharp</a>
     |
      <a href="/category/code">code</a>
     |
      <a href="/category/f-sharp">f-sharp</a>
     |
      <a href="/category/language">language</a>
      </div>
</nav>
<p>There&rsquo;s nothing like travelling abroad to make you see your home country with
new eyes. While your first fascination with everything new and different in the
foreign land may enventually be replaced by homesickness, you always want to
bring back a souvenir, a little bit of the best of where you&rsquo;ve been.</p>
<p>C# is my home country these days, but I&rsquo;ve been vacationing in F#. There&rsquo;s a lot
there that&rsquo;s absolutely brilliant, like <a href="http://en.wikipedia.org/wiki/Currying">currying</a> and <a href="http://ejohn.org/blog/partial-functions-in-javascript/">partial
application</a>, <a href="http://www.infoq.com/articles/pickering-fsharp-workflow">workflows</a>, and <a href="http://www.markhneedham.com/blog/2009/01/02/f-option-types/">option types</a> (no more
<a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/">NullReferenceExceptions</a>!). But one of the first things I fell in love with
in the language was pattern matching. Pattern matching in F# (and its ancestors
ML and OCaml) is something like <code>switch/case</code> on steroids. Here&rsquo;s a simple
example of a <code>switch/case</code> in C#:</p>
<pre class="highlight language-csharp"><span class="t">int</span> <span class="i">i</span> <span class="o">=</span> <span class="n">2</span><span class="p">;</span>
<span class="k">switch</span> <span class="p">(</span><span class="i">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">case</span> <span class="n">0</span><span class="p">:</span>  <span class="i">Print</span><span class="p">(</span><span class="s">&quot;zero&quot;</span><span class="p">);</span>
    <span class="k">case</span> <span class="n">1</span><span class="p">:</span>  <span class="i">Print</span><span class="p">(</span><span class="s">&quot;one&quot;</span><span class="p">);</span>
    <span class="k">case</span> <span class="n">2</span><span class="p">:</span>  <span class="i">Print</span><span class="p">(</span><span class="s">&quot;two&quot;</span><span class="p">);</span>
    <span class="k">default</span><span class="p">:</span> <span class="i">Print</span><span class="p">(</span><span class="s">&quot;some other value&quot;</span><span class="p">);</span>
<span class="p">}</span></pre>
<p>Here&rsquo;s what the same logic would look like in F#:</p>
<pre class="highlight language-fsharp"><span class="k">let</span> <span class="i">i</span> <span class="o">=</span> <span class="n">2</span>
<span class="k">match</span> <span class="i">i</span> <span class="k">with</span>
<span class="o">|</span> <span class="n">0</span> <span class="o">-&gt;</span> <span class="i">Print</span><span class="p">(</span><span class="s">&quot;zero&quot;</span><span class="p">)</span>
<span class="o">|</span> <span class="n">1</span> <span class="o">-&gt;</span> <span class="i">Print</span><span class="p">(</span><span class="s">&quot;one&quot;</span><span class="p">)</span>
<span class="o">|</span> <span class="n">2</span> <span class="o">-&gt;</span> <span class="i">Print</span><span class="p">(</span><span class="s">&quot;two&quot;</span><span class="p">)</span>
<span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="i">Print</span><span class="p">(</span><span class="s">&quot;some other value&quot;</span><span class="p">)</span></pre>
<p>You can probably infer what&rsquo;s going on. Pretty similar to our familiar
<code>switch/case</code>. It checks each value and executes the clause on the right the
first time it finds a match. The <code>_</code> bit on the last line is equivalent to
<code>default</code> in a <code>switch/case</code>: it always gets matched if we get that far. Basic
stuff, but pattern matching can do so much more. Before I can explain <em>that</em>,
though, we&rsquo;ll need to take a little side trip to see another F# feature:
<a href="http://en.wikipedia.org/wiki/Variant_record">discriminated unions</a>.</p>
<h2 id="discriminated-unions"><a href="#discriminated-unions">Discriminated unions<span class="anchor">#discriminated-unions</span></a></h2>
<p>Where C# has enums, F# has discriminated unions. The main difference between the
two is that each value in the union can have additional data fields. Imagine you
want to enumerate the different kinds of <a href="http://en.wikipedia.org/wiki/Image_macro">image macros</a>:</p>
<pre class="highlight language-csharp"><span class="k">enum</span> <span class="t">ImageMacro</span>
<span class="p">{</span>
    <span class="i">Lolcat</span><span class="p">,</span>
    <span class="i">Lolrus</span><span class="p">,</span>
    <span class="i">ORlyOwl</span>
<span class="p">}</span></pre>
<p>Pretty basic. Now if it&rsquo;s a <a href="http://en.wikipedia.org/wiki/Lolcat">lolcat</a>, we also want to note the text of the
caption, and if it&rsquo;s a <a href="http://icanhascheezburger.com/2007/01/14/i-has-a-bucket/">lolrus</a>, we want to note how many buckets it has. In
C#, we&rsquo;d have to ditch the enum and resort to a class hierarchy:</p>
<pre class="highlight language-csharp"><span class="k">abstract</span> <span class="k">class</span> <span class="t">ImageMacro</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">class</span> <span class="t">Lolcat</span> <span class="p">:</span> <span class="t">ImageMacro</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="t">string</span> <span class="i">Caption</span><span class="p">;</span>
    <span class="k">public</span> <span class="i">Lolcat</span><span class="p">(</span><span class="t">string</span> <span class="i">caption</span><span class="p">)</span> <span class="p">{</span> <span class="i">Caption</span> <span class="o">=</span> <span class="i">caption</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="t">Lolrus</span> <span class="p">:</span> <span class="t">ImageMacro</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="t">int</span> <span class="i">Buckets</span><span class="p">;</span>
    <span class="k">public</span> <span class="i">Lolrus</span><span class="p">(</span><span class="t">int</span> <span class="i">buckets</span><span class="p">)</span> <span class="p">{</span> <span class="i">Buckets</span> <span class="o">=</span> <span class="i">buckets</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="t">ORlyOwl</span> <span class="p">:</span> <span class="t">ImageMacro</span> <span class="p">{</span> <span class="p">}</span></pre>
<p>Classic OOP design, and it gets the job done. In F#, you can simply add fields
to a discriminated union and accomplish the exact same thing:</p>
<pre class="highlight language-fsharp"><span class="k">type</span> <span class="i">ImageMacro</span> <span class="o">=</span>
    <span class="o">|</span> <span class="i">Lolcat</span>    <span class="k">of</span> <span class="i">string</span>
    <span class="o">|</span> <span class="i">Lolrus</span>    <span class="k">of</span> <span class="i">int</span>
    <span class="o">|</span> <span class="i">ORlyOwl</span></pre>
<p>The <code>of string</code> says that when you make a Lolcat ImageMacro (and <em>only</em> a
Lolcat) that you must also provide a caption. Likewise, the <code>of int</code> says that a
Lolrus needs a number of buckets.</p>
<h2 id="pattern-matching-discriminated-unions"><a href="#pattern-matching-discriminated-unions">Pattern matching discriminated unions<span class="anchor">#pattern-matching-discriminated-unions</span></a></h2>
<p>These two features, pattern matching and discriminated unions, go together in F#
like gondolas and striped shirts. Each is much less awesome without the other.
Now let&rsquo;s get back to pattern matching and see something it can do that a
<code>switch/case</code> definitely can&rsquo;t. Given our above ImageMacro type, let&rsquo;s say we
want to print it out:</p>
<pre class="highlight language-fsharp"><span class="k">let</span> <span class="i">image</span> <span class="o">=</span> <span class="i">Lolcat</span><span class="p">(</span><span class="s">&quot;I made you a cookie&quot;</span><span class="p">)</span>
<span class="k">match</span> <span class="i">image</span> <span class="k">with</span>
<span class="o">|</span> <span class="i">Lolcat</span><span class="p">(</span><span class="i">caption</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="i">Print</span><span class="p">(</span><span class="s">&quot;Lolcat says &#39;&quot;</span> <span class="o">+</span> <span class="i">caption</span> <span class="o">+</span> <span class="s">&quot;&#39;&quot;</span><span class="p">)</span>
<span class="o">|</span> <span class="i">Lolrus</span><span class="p">(</span><span class="i">buckets</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="i">Print</span><span class="p">(</span><span class="s">&quot;Lolrus has &quot;</span> <span class="o">+</span> <span class="i">buckets</span> <span class="o">+</span> <span class="s">&quot; buckets&quot;</span><span class="p">)</span>
<span class="o">|</span> <span class="i">ORlyOwn</span>         <span class="o">-&gt;</span> <span class="i">Print</span><span class="p">(</span><span class="s">&quot;O RLY?&quot;</span><span class="p">)</span></pre>
<p>Now <em>that&rsquo;s</em> pretty nice. Not only does it switch on what kind of image macro
it is, it also pulls out the data associated with each one (&ldquo;destructures&rdquo; in
the local parlance). This would definitely be nice to have in C#.</p>
<h2 id="a-little-souvenir-patternmatch"><a href="#a-little-souvenir-patternmatch">A little souvenir: <code>Pattern.Match</code><span class="anchor">#a-little-souvenir-patternmatch</span></a></h2>
<p>So can we bring discriminated union pattern matching back to C#? Since C#
doesn&rsquo;t have discriminated unions, we&rsquo;ll have to make it work with the little
inheritance tree up there. Here&rsquo;s what I got:</p>
<pre class="highlight language-csharp"><span class="t">ImageMacro</span> <span class="i">image</span> <span class="o">=</span> <span class="k">new</span> <span class="t">Lolcat</span><span class="p">(</span><span class="s">&quot;I made you a cookie&quot;</span><span class="p">);</span>
<span class="i">Pattern</span><span class="p">.</span><span class="i">Match</span><span class="p">(</span><span class="i">image</span><span class="p">).</span>
    <span class="t">Case</span><span class="o">&lt;</span><span class="t">Lolcat</span><span class="p">,</span> <span class="t">string</span><span class="o">&gt;</span> <span class="p">(</span><span class="i">c</span>  <span class="o">=&gt;</span> <span class="i">Print</span><span class="p">(</span><span class="s">&quot;Lolcat says &#39;&quot;</span> <span class="o">+</span> <span class="i">c</span> <span class="o">+</span> <span class="s">&quot;&#39;&quot;</span><span class="p">)).</span>
    <span class="t">Case</span><span class="o">&lt;</span><span class="t">Lolrus</span><span class="p">,</span> <span class="t">int</span><span class="o">&gt;</span>    <span class="p">(</span><span class="i">b</span>  <span class="o">=&gt;</span> <span class="i">Print</span><span class="p">(</span><span class="s">&quot;I has &quot;</span> <span class="o">+</span> <span class="i">b</span> <span class="o">+</span> <span class="s">&quot; buckets&quot;</span><span class="p">)).</span>
    <span class="t">Case</span><span class="o">&lt;</span><span class="t">ORlyOwl</span><span class="o">&gt;</span>        <span class="p">(()</span> <span class="o">=&gt;</span> <span class="i">Print</span><span class="p">(</span><span class="s">&quot;O RLY?&quot;</span><span class="p">));</span></pre>
<p>A little strange, but not <em>too</em> bad. Looks kind of like a <code>switch/case</code> but
switches based on type. For <code>Lolcat</code> and <code>Lolrus</code>, we pull out the caption and
number of buckets. How does this work? Let&rsquo;s build it from the bottom up.</p>
<h2 id="the-case-method"><a href="#the-case-method">The <code>Case()</code> method<span class="anchor">#the-case-method</span></a></h2>
<p>A single case in our pattern matcher needs to specify three things: the type
being selected (Lolcat, Lolrus, etc.), the field(s) to pull out (if any), and
the action to perform when the case is successfully matched. Let&rsquo;s start with
the simplest possible system: one that can only match a single value based on
type, with no fields. Here&rsquo;s the basic class:</p>
<pre class="highlight language-csharp"><span class="k">public</span> <span class="k">class</span> <span class="t">Matcher</span><span class="o">&lt;</span><span class="t">T</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="i">Matcher</span><span class="p">(</span><span class="t">T</span> <span class="i">value</span><span class="p">)</span> <span class="p">{</span> <span class="i">mValue</span> <span class="o">=</span> <span class="i">value</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="t">Case</span><span class="o">&lt;</span><span class="t">TCase</span><span class="o">&gt;</span><span class="p">(</span><span class="t">Action</span> <span class="i">action</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="i">mValue</span> <span class="k">is</span> <span class="t">TCase</span><span class="p">)</span> <span class="i">action</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="t">T</span> <span class="i">mValue</span><span class="p">;</span>
<span class="p">}</span></pre>
<p>The action being passed in is a delegate, and we construct it using C# 3.5&rsquo;s
handy lambda notation. For the ORlyOwl, it&rsquo;s:</p>
<pre class="highlight language-csharp"><span class="p">()</span> <span class="o">=&gt;</span> <span class="i">Print</span><span class="p">(</span><span class="s">&quot;O RLY?&quot;</span><span class="p">)</span></pre>
<p>Aside from being a nice clean notation, the other nice thing about lambdas (and
anonymous delegates) is that they can access variables defined in the outside
scope. This lets our <code>Case</code> clauses do everything a regular <code>case</code> can do in a
vanilla <code>switch/case</code>.</p>
<h3 id="chaining-cases-using-a-fluent-interface"><a href="#chaining-cases-using-a-fluent-interface">Chaining cases using a fluent interface<span class="anchor">#chaining-cases-using-a-fluent-interface</span></a></h3>
<p>What we have so far is simple, but it only lets us select a single case. To be
able to chain multiple cases together, we&rsquo;re going to use something the hip
kids are calling a &ldquo;fluent interface&rdquo;. The basic idea is to make methods
return <code>this</code> so that you can call multiple methods on the same object by
<code>chaining.Them().Like().This()</code>:</p>
<pre class="highlight language-csharp"><span class="k">public</span> <span class="t">Matcher</span><span class="o">&lt;</span><span class="t">T</span><span class="o">&gt;</span> <span class="t">Case</span><span class="o">&lt;</span><span class="t">TCase</span><span class="o">&gt;</span><span class="p">(</span><span class="t">Action</span> <span class="i">action</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="i">mValue</span> <span class="k">is</span> <span class="t">TCase</span><span class="p">)</span> <span class="i">action</span><span class="p">();</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
<span class="p">}</span></pre>
<h3 id="preventing-multiple-matches"><a href="#preventing-multiple-matches">Preventing multiple matches<span class="anchor">#preventing-multiple-matches</span></a></h3>
<p>There&rsquo;s a problem here. A pattern should only match the <em>first</em> successful case.
If we just allow arbitrary chaining, it would be possible to have multiple
matches. Here&rsquo;s a solution:</p>
<pre class="highlight language-csharp"><span class="k">public</span> <span class="k">virtual</span> <span class="t">Matcher</span><span class="o">&lt;</span><span class="t">T</span><span class="o">&gt;</span> <span class="t">Case</span><span class="o">&lt;</span><span class="t">TCase</span><span class="o">&gt;</span><span class="p">(</span><span class="t">Action</span> <span class="i">action</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="i">mValue</span> <span class="k">is</span> <span class="t">TCase</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="i">action</span><span class="p">();</span>
        <span class="k">return</span> <span class="k">new</span> <span class="t">NullMatcher</span><span class="o">&lt;</span><span class="t">T</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
<span class="p">}</span></pre>
<p>Now when we have a successful match, instead of continuing the fluent
interface and returning <code>this</code>, we return a <code>NullMatcher&lt;T&gt;</code> As you can
probably guess, that class has the same methods as <code>Matcher&lt;T&gt;</code>, but never
actually matches:</p>
<pre class="highlight language-csharp"><span class="k">public</span> <span class="k">class</span> <span class="t">NullMatcher</span><span class="o">&lt;</span><span class="t">T</span><span class="o">&gt;</span> <span class="p">:</span> <span class="t">Matcher</span><span class="o">&lt;</span><span class="t">T</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">override</span> <span class="t">Matcher</span><span class="o">&lt;</span><span class="t">T</span><span class="o">&gt;</span> <span class="t">Case</span><span class="o">&lt;</span><span class="t">TCase</span><span class="o">&gt;</span><span class="p">(</span><span class="t">Action</span> <span class="i">action</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></pre>
<h3 id="extracting-fields"><a href="#extracting-fields">Extracting fields<span class="anchor">#extracting-fields</span></a></h3>
<p>So far, we&rsquo;re up to being able to do this:</p>
<pre class="highlight language-csharp"><span class="i">Pattern</span><span class="p">.</span><span class="i">Match</span><span class="p">(</span><span class="i">image</span><span class="p">).</span>
    <span class="t">Case</span><span class="o">&lt;</span><span class="t">Lolcat</span><span class="o">&gt;</span> <span class="p">(()</span> <span class="o">=&gt;</span> <span class="i">Print</span><span class="p">(</span><span class="s">&quot;Lolcat says &#39;?&#39;&quot;</span><span class="p">)).</span>
    <span class="t">Case</span><span class="o">&lt;</span><span class="t">Lolrus</span><span class="o">&gt;</span> <span class="p">(()</span> <span class="o">=&gt;</span> <span class="i">Print</span><span class="p">(</span><span class="s">&quot;Lolrus has ? buckets&quot;</span><span class="p">)).</span>
    <span class="t">Case</span><span class="o">&lt;</span><span class="t">ORlyOwl</span><span class="o">&gt;</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="i">Print</span><span class="p">(</span><span class="s">&quot;O RLY?&quot;</span><span class="p">));</span></pre>
<p>The last remaining step is to pull out the <code>caption</code> and <code>buckets</code> from the
<code>Lolcat</code> and <code>Lolrus</code> types. We&rsquo;ll do this by overloading <code>Case()</code>:</p>
<pre class="highlight language-csharp"><span class="k">public</span> <span class="k">virtual</span> <span class="t">Matcher</span><span class="o">&lt;</span><span class="t">T</span><span class="o">&gt;</span> <span class="t">Case</span><span class="o">&lt;</span><span class="t">TCase</span><span class="p">,</span> <span class="t">TArg</span><span class="o">&gt;</span><span class="p">(</span><span class="t">Action</span><span class="o">&lt;</span><span class="t">TArg</span><span class="o">&gt;</span> <span class="i">action</span><span class="p">)</span>
<span class="p">{</span>
    <span class="t">IMatchable</span><span class="o">&lt;</span><span class="t">TArg</span><span class="o">&gt;</span> <span class="i">matchable</span> <span class="o">=</span> <span class="i">mValue</span> <span class="k">as</span> <span class="t">IMatchable</span><span class="o">&lt;</span><span class="t">TArg</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">((</span><span class="i">matchable</span> <span class="o">!=</span> <span class="k">null</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="i">mValue</span> <span class="k">is</span> <span class="t">TCase</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="i">action</span><span class="p">(</span><span class="i">matchable</span><span class="p">.</span><span class="i">GetArg</span><span class="p">());</span>
        <span class="k">return</span> <span class="k">new</span> <span class="t">NullMatcher</span><span class="o">&lt;</span><span class="t">T</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></pre>
<p>What this new method does is both check the value&rsquo;s type and see if it
implements <code>IMatchable&lt;T&gt;</code>. That little interface lets a class expose a field
for pattern matching. (We could also do this using reflection. That would free
us up from having explicitly implement pattern matching support in classes, but
would also incur a performance penalty and bind the pattern matching to the
internals of the matched classes.) Here&rsquo;s the interface and its implementation
in our macro classes:</p>
<pre class="highlight language-csharp"><span class="k">interface</span> <span class="t">IMatchable</span><span class="o">&lt;</span><span class="t">TArg</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="t">TArg</span> <span class="i">GetArg</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">class</span> <span class="t">Lolcat</span> <span class="p">:</span> <span class="t">ImageMacro</span><span class="p">,</span> <span class="t">IMatchable</span><span class="o">&lt;</span><span class="t">string</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="t">string</span> <span class="i">Caption</span><span class="p">;</span>
    <span class="k">public</span> <span class="i">Lolcat</span><span class="p">(</span><span class="t">string</span> <span class="i">caption</span><span class="p">)</span> <span class="p">{</span> <span class="i">Caption</span> <span class="o">=</span> <span class="i">caption</span><span class="p">;</span> <span class="p">}</span>

    <span class="t">string</span> <span class="t">IMatchable</span><span class="o">&lt;</span><span class="t">string</span><span class="o">&gt;</span><span class="p">.</span><span class="i">GetArg</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="i">Caption</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="t">Lolrus</span> <span class="p">:</span> <span class="t">ImageMacro</span><span class="p">,</span> <span class="t">IMatchable</span><span class="o">&lt;</span><span class="t">int</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="t">int</span> <span class="i">NumBuckets</span><span class="p">;</span>
    <span class="k">public</span> <span class="i">Lolrus</span><span class="p">(</span><span class="t">int</span> <span class="i">numBuckets</span><span class="p">)</span> <span class="p">{</span> <span class="i">NumBuckets</span> <span class="o">=</span> <span class="i">numBuckets</span><span class="p">;</span> <span class="p">}</span>

    <span class="t">int</span> <span class="t">IMatchable</span><span class="o">&lt;</span><span class="t">int</span><span class="o">&gt;</span><span class="p">.</span><span class="i">GetArg</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="i">NumBuckets</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></pre>
<p>I&rsquo;m using explicit interface implementation here, because users only really
care about using <code>GetArg()</code> when they&rsquo;re doing pattern matching. Otherwise,
there&rsquo;s no reason to make it a visible part of the class&rsquo;s interface.</p>
<h2 id="the-pattern-class"><a href="#the-pattern-class">The <code>Pattern</code> class<span class="anchor">#the-pattern-class</span></a></h2>
<p>We&rsquo;ve built back almost up the to the top. The last little bit left is the
simplest:</p>
<pre class="highlight language-csharp"><span class="i">Pattern</span><span class="p">.</span><span class="i">Match</span><span class="p">(</span><span class="i">image</span><span class="p">)</span></pre>
<p><code>Pattern</code> is simply a static class with one method <code>Match()</code>:</p>
<pre class="highlight language-csharp"><span class="k">class</span> <span class="t">Pattern</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="t">Matcher</span><span class="o">&lt;</span><span class="t">T</span><span class="o">&gt;</span> <span class="t">Match</span><span class="o">&lt;</span><span class="t">T</span><span class="o">&gt;</span><span class="p">(</span><span class="t">T</span> <span class="i">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="t">Matcher</span><span class="o">&lt;</span><span class="t">T</span><span class="o">&gt;</span><span class="p">(</span><span class="i">value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></pre>
<p>The Pattern class exists simply because C# requires all functions to be in a
class. However, constructing Matchers through <code>Match&lt;T&gt;</code> does have one nice
side-effect: it lets the compiler infer the type parameter so you don&rsquo;t have to
explicitly write it out like you would when calling a constructor.</p>
<p>With this little bit in place, we&rsquo;ve reached our goal of being able to get
something like matching discriminated unions working in C#:</p>
<pre class="highlight language-csharp"><span class="i">Pattern</span><span class="p">.</span><span class="i">Match</span><span class="p">(</span><span class="i">image</span><span class="p">).</span>
    <span class="t">Case</span><span class="o">&lt;</span><span class="t">Lolcat</span><span class="p">,</span> <span class="t">string</span><span class="o">&gt;</span><span class="p">(</span><span class="i">c</span>  <span class="o">=&gt;</span> <span class="i">Print</span><span class="p">(</span><span class="s">&quot;Lolcat says &#39;&quot;</span> <span class="o">+</span> <span class="i">c</span> <span class="o">+</span> <span class="s">&quot;&#39;&quot;</span><span class="p">)).</span>
    <span class="t">Case</span><span class="o">&lt;</span><span class="t">Lolrus</span><span class="p">,</span> <span class="t">int</span><span class="o">&gt;</span>   <span class="p">(</span><span class="i">b</span>  <span class="o">=&gt;</span> <span class="i">Print</span><span class="p">(</span><span class="s">&quot;I has &quot;</span> <span class="o">+</span> <span class="i">b</span> <span class="o">+</span> <span class="s">&quot; buckets&quot;</span><span class="p">)).</span>
    <span class="t">Case</span><span class="o">&lt;</span><span class="t">ORlyOwl</span><span class="o">&gt;</span>       <span class="p">(()</span> <span class="o">=&gt;</span> <span class="i">Print</span><span class="p">(</span><span class="s">&quot;O RLY?&quot;</span><span class="p">));</span></pre>
<h2 id="but-wait-thats-not-all"><a href="#but-wait-thats-not-all">But wait, that&rsquo;s not all!<span class="anchor">#but-wait-thats-not-all</span></a></h2>
<p>This is only the beginning of what we can do with our little matching class.
Here are a few other things the full code lets you do:</p>
<h3 id="extracting-multiple-fields"><a href="#extracting-multiple-fields">Extracting multiple fields<span class="anchor">#extracting-multiple-fields</span></a></h3>
<p>In the example above, we only pull a single field out of a given case. F#
supports multiple fields as well, as does the Matcher class (up to four):</p>
<pre class="highlight language-csharp"><span class="t">Case</span><span class="o">&lt;</span><span class="t">Loldog</span><span class="p">,</span> <span class="t">string</span><span class="p">,</span> <span class="t">int</span><span class="o">&gt;</span> <span class="p">((</span><span class="i">caption</span><span class="p">,</span> <span class="i">dogs</span><span class="p">)</span> <span class="o">=&gt;</span>
    <span class="i">Print</span><span class="p">(</span><span class="s">&quot;&#39;&quot;</span> <span class="o">+</span> <span class="i">caption</span> <span class="o">+</span> <span class="s">&quot;&#39;, says &quot;</span> <span class="o">+</span> <span class="i">dogs</span> <span class="o">+</span> <span class="s">&quot; hotdogs&quot;</span><span class="p">)).</span></pre>
<h3 id="a-default-case"><a href="#a-default-case">A default case<span class="anchor">#a-default-case</span></a></h3>
<p>It&rsquo;s also useful to have a <code>default</code>-like case that will always succeed if no
other case matches:</p>
<pre class="highlight language-csharp"><span class="i">Pattern</span><span class="p">.</span><span class="i">Match</span><span class="p">(</span><span class="i">image</span><span class="p">).</span>
    <span class="t">Case</span><span class="o">&lt;</span><span class="t">Lolrus</span><span class="p">,</span> <span class="t">int</span><span class="o">&gt;</span> <span class="p">(</span><span class="i">b</span>  <span class="o">=&gt;</span> <span class="i">Print</span><span class="p">(</span><span class="s">&quot;I has &quot;</span> <span class="o">+</span> <span class="i">buckets</span> <span class="o">+</span> <span class="s">&quot; buckets&quot;</span><span class="p">)).</span>
    <span class="i">Default</span>           <span class="p">(()</span> <span class="o">=&gt;</span> <span class="i">Print</span><span class="p">(</span><span class="s">&quot;Default&quot;</span><span class="p">));</span></pre>
<h3 id="equality-matching"><a href="#equality-matching">Equality matching<span class="anchor">#equality-matching</span></a></h3>
<p>Another way to match values is if they are equal. We can do this generically
since <code>Equals()</code> is part of the .NET framework.</p>
<pre class="highlight language-csharp"><span class="i">Pattern</span><span class="p">.</span><span class="i">Match</span><span class="p">(</span><span class="s">&quot;a string&quot;</span><span class="p">).</span>
    <span class="i">Case</span><span class="p">(</span><span class="s">&quot;not&quot;</span><span class="p">,</span>      <span class="p">()</span> <span class="o">=&gt;</span> <span class="i">Print</span><span class="p">(</span><span class="s">&quot;should not match&quot;</span><span class="p">)).</span>
    <span class="i">Case</span><span class="p">(</span><span class="s">&quot;a string&quot;</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="i">Print</span><span class="p">(</span><span class="s">&quot;should match&quot;</span><span class="p">));</span></pre>
<p>The example here uses strings, but this works with any type as long as it
implements <code>Equals()</code> correctly.</p>
<h3 id="matching-on-any-predicate"><a href="#matching-on-any-predicate">Matching on any predicate<span class="anchor">#matching-on-any-predicate</span></a></h3>
<p>As you can see, there are a bunch of different ways users may want to match
data, and it&rsquo;s futile to try to bake all of them into the class. The most
obvious solution then is to simply let users pass in an arbitrary predicate (a
predicate is a function that returns a bool) and have the match succeed based
on that:</p>
<pre class="highlight language-csharp"><span class="i">Pattern</span><span class="p">.</span><span class="i">Match</span><span class="p">(</span><span class="n">123</span><span class="p">).</span>
    <span class="i">Case</span><span class="p">(</span><span class="i">value</span> <span class="o">=&gt;</span> <span class="i">value</span> <span class="o">&lt;</span> <span class="n">100</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="i">Print</span><span class="p">(</span><span class="s">&quot;less than 100&quot;</span><span class="p">)).</span>
    <span class="i">Case</span><span class="p">(</span><span class="i">value</span> <span class="o">=&gt;</span> <span class="i">value</span> <span class="o">&gt;</span> <span class="n">100</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="i">Print</span><span class="p">(</span><span class="s">&quot;greater than 100&quot;</span><span class="p">));</span></pre>
<p>You&rsquo;ll note that in the final code below, all of the other matching types are
built on top of this.</p>
<h3 id="returning-a-value"><a href="#returning-a-value">Returning a value<span class="anchor">#returning-a-value</span></a></h3>
<p>F#, unlike C#, treats everything as an expression, even flow control
statements like <code>if/then</code> and <code>match</code>. This means a match can return a result:</p>
<pre class="highlight language-fsharp"><span class="c">// F#:</span>
<span class="k">let</span> <span class="i">isTwo</span> <span class="o">=</span> <span class="k">match</span> <span class="n">2</span> <span class="k">with</span>
            <span class="o">|</span> <span class="n">2</span> <span class="o">-&gt;</span> <span class="k">true</span>
            <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="k">false</span></pre>
<p>In C#, you&rsquo;d have to do an assignment:</p>
<pre class="highlight language-csharp"><span class="c">// C#:</span>
<span class="t">bool</span> <span class="i">isTwo</span><span class="p">;</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">case</span> <span class="n">2</span><span class="p">:</span>  <span class="i">isTwo</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="k">default</span><span class="p">:</span> <span class="i">isTwo</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
<span class="p">}</span></pre>
<p>Our pattern matching class can do this too, even within C#:</p>
<pre class="highlight language-csharp"><span class="t">bool</span> <span class="i">isTwo</span> <span class="o">=</span> <span class="i">Pattern</span><span class="p">.</span><span class="i">Match</span><span class="o">&lt;</span><span class="t">int</span><span class="p">,</span> <span class="t">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">2</span><span class="p">).</span>
                 <span class="i">Case</span><span class="p">(</span><span class="n">2</span><span class="p">,</span>  <span class="k">true</span><span class="p">).</span>
                 <span class="i">Default</span><span class="p">(</span> <span class="k">false</span><span class="p">);</span></pre>
<h2 id="conclusion"><a href="#conclusion">Conclusion<span class="anchor">#conclusion</span></a></h2>
<p>They say you never know your home until you travel abroad. I&rsquo;ve been enjoying F#
a lot, but C# still feels more comfortable to me. However, it&rsquo;s always useful to
see how other languages solve problems, and see what new techniques can be
brought home with you. While our pattern matching class isn&rsquo;t quite as clean in
C# as it is in F#, I think it&rsquo;s a useful tool in its own right.</p><div class="update">
<p><em>Update 2021/10/05:</em> Moved it to <a href="https://github.com/munificent/pattern_matching">GitHub</a>.</p>
</div>
<p>If you&rsquo;d like to play with it, <a href="https://github.com/munificent/pattern_matching">I&rsquo;ve put it up on GitHub</a>. Have fun!</p>
<div class="comments">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
      var disqus_shortname = 'journal-stuffwithstuff';
      var disqus_url = "https://journal.stuffwithstuff.com/2009/05/13/ml-style-pattern-matching-in-c/";

      (function() {
          var dsq = document.createElement('script');
          dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</article>
<footer id="footer">
  <figure>
  <a href="/"><img src="/image/dogshot_square.jpg"></a>
  </figure>
  <p>Hi! I'm Bob Nystrom. (I'm the one with glasses, not the
    <a href="/2022/02/13/stupid-dog/">dog</a>.) I wrote <a href="https://gameprogrammingpatterns.com/">Game Programming Patterns</a> and
    <a href="https://craftinginterpreters.com">Crafting Interpreters</a>. I
    make electronic music under the name
    <a href="https://tinywir.es/">Tiny Wires</a>.</p>
  <p>I'm on <a href="https://mastodon.social/@munificent">Mastodon</a> and <a href="https://bsky.app/profile/stuffwithstuff.com">Bluesky</a>, or you can email me at <code>robert</code> at this site.</p>
  <p>I built this blog using a bespoke static site generator and wrote every single word myself. The source repo
  is <a href="https://github.com/munificent/journal">here</a>.</p>
  <div class="nav-second">
  </div>
  <p class="copyright">&copy; 2008-2025 Bob Nystrom</p>
</footer>
    </main>
  </body>
 </html>
