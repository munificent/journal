<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link href='http://fonts.googleapis.com/css?family=Source+Code+Pro|PT+Serif:400,700,400italic,700italic' rel='stylesheet' type='text/css'>

    <!-- Tell mobile browsers we're optimized for them and they don't need to
         crop the viewport. -->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
    <link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/rss.xml" />
    <link rel="alternate" type="application/atom+xml" title="Atom 1.0" href="/atom.xml" />
    <link rel="stylesheet" href="/style.css" type="text/css" />

    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">

    <title>
      Multimethods, Multiple Inheritance, Multiawesome!
      
        &ndash; journal.stuffwithstuff.com
      
    </title>
  </head>
  <body>
    <div class="column">
      
<article>
<header>
<h1>
  <a href="/2011/04/21/multimethods-multiple-inheritance-multiawesome" rel="bookmark"
     title="Permanent Link to Multimethods, Multiple Inheritance, Multiawesome!">
    Multimethods, Multiple Inheritance, Multiawesome!
  </a>
</h1>

  <a class="older" href="/2011/03/19/pratt-parsers-expression-parsing-made-easy"
     title="Older Post &ldquo;Pratt Parsers: Expression Parsing Made Easy&rdquo;">&#8617;</a>


  <a class="newer" href="/2011/06/06/magpie-wants-you"
     title="Newer Post &ldquo;Magpie Wants You!&rdquo;">&#8618;</a>

</header>
<h4><a href="/archive">April 21, 2011</a>
    <span class="tags"><a href="/category/code">code</a> <a href="/category/cpp">cpp</a> <a href="/category/java">java</a> <a href="/category/js">js</a> <a href="/category/language">language</a> <a href="/category/magpie">magpie</a></span>
</h4>

<p>The luxury of having <a href="http://magpie.stuffwithstuff.com">a programming language with zero users</a> is that I can make <a href="https://github.com/munificent/magpie/commit/e509e13fd74ba252faf00288196769412cf7811c">radical changes</a> to it with impunity. Over the past month, I&rsquo;ve done just that. I&rsquo;ve been thinking about both multimethods and multiple inheritance for a long time, but I couldn&rsquo;t figure out how to make them work. They both finally clicked together: I found a way to use each to solve my problems with the other.</p>

<p>With those stumbling blocks behind me, I was free to rebuild the language into a form I&rsquo;ve really wanted it to have since I started. Where Magpie used to be a more typical <a href="http://c2.com/cgi/wiki?SingleDispatch">single-dispatch</a> single-inheritance OOP language, it&rsquo;s now much closer to <a href="http://en.wikipedia.org/wiki/Common_Lisp_Object_System">CLOS</a>.</p>

<p>This is a fundamental change to the language: every time you call a method, you&rsquo;re going through totally different machinery to figure out what code gets executed. What I&rsquo;m really excited about is that I feel like the language is more powerful now and yet simpler.</p>

<p>Since not a lot of people know anything about multimethods (and I&rsquo;m still learning!), and most people these days think multiple inheritance is in the same category as punching children and littering, I thought it might be worth running through how and why I added them. If I can, I&rsquo;ll show you some fun stuff that gets a lot easier when you have them.</p>

<h2>What&rsquo;s Multiple Inheritance?</h2>

<p>If you&rsquo;ve played with C++, you&rsquo;re at least passingly familiar with multiple inheritance. It&rsquo;s exactly like it sounds: a class can inherit from multiple base classes. All of the methods and properties on the base classes are available on the new derived one.</p>

<p>This is strictly more expressive than single inheritance. Single inheritance gets you pretty far, but I find it leads to deeper inheritance chains, more redundancy, and more brittleness. With multiple inheritance, you&rsquo;re free to split classes into small chunks of well-defined behavior and then recompose them at will. <a href="http://journal.stuffwithstuff.com/2011/02/21/multiple-inheritance-in-javascript">This post</a>, I hope, gives you a good idea of what I have in mind here.</p>

<h2>What&rsquo;s the Problem?</h2>

<p>It&rsquo;s not all rosy though, as anyone whose sliced their hand open on the <a href="http://en.wikipedia.org/wiki/Deadly_Diamond_of_Death">deadly diamond of death</a> can tell you. Here are a couple of problems that you can run into:</p>

<h3>Is State Duplicated or Not?</h3>

<p>Let&rsquo;s say you&rsquo;re making a game. You&rsquo;ve got classes for the things in the world: monsters, magical items, etc. Lots of things in the world have a position, so you make a base class for that:</p>
<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span></span><span class="k">class</span> <span class="nc">Positioned</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Then you derive classes for items and monsters:</p>
<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span></span><span class="k">class</span> <span class="nc">Item</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Positioned</span> <span class="p">{</span>
  <span class="c1">// stuff...</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Monster</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Positioned</span> <span class="p">{</span>
  <span class="c1">// stuff...</span>
<span class="p">}</span>
</code></pre></div>
<p>Groovy. Then you decide to add a <a href="http://wiki.ffxiclopedia.org/wiki/Treasure_Chest_%28Monster%29">living treasure chest monster</a> to attack the unwary:</p>
<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span></span><span class="k">class</span> <span class="nc">ChestMonster</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Monster</span><span class="p">,</span> <span class="k">public</span> <span class="n">Item</span> <span class="p">{</span>
  <span class="c1">// stuff...</span>
<span class="p">}</span>
</code></pre></div>
<p>Pop quiz! Does our <code>ChestMonster</code> have one <code>x</code> field or two? I&rsquo;ve coded a lot of C++ and I honestly don&rsquo;t know the answer. Either way it&rsquo;s bad.</p>

<p>If it gets two sets of position, one for each path in the class hierarchy, then how do you know which one you&rsquo;re getting when you access <code>x</code> on an instance of <code>ChestMonster</code>? If it just gets one <code>x</code>, what happens if the constructors for <code>Item</code> and <code>Monster</code> try to pass different values for it when they call the constructor for <code>Positioned</code> from their constructor? Who wins?</p>

<h3>Which Override Wins?</h3>

<p>Now let&rsquo;s expand our previous example. Let&rsquo;s say there&rsquo;s a virtual method in <code>Positioned</code> so that a derived class can say whether or not a given position is valid. Something like:</p>
<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span></span><span class="k">class</span> <span class="nc">Positioned</span> <span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
  <span class="kt">bool</span> <span class="n">isPositionValid</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>This way, derived classes can handle things like ghosts that can walk through walls or items that float on water. So <code>Item</code> and <code>Monster</code> both override it. When it gets called from an instance of <code>ChestMonster</code>, which one wins?</p>

<p>There probably <em>is</em> an answer here, but even if it&rsquo;s unambiguous to the language, it&rsquo;s confusing for the user.</p>

<h3>Other Problems&hellip;</h3>

<p>There are some other annoyances too. Multiple inheritance means you need syntax for calling all of your base class constructors, which is a bit more complex than Java&rsquo;s simple <code>super(...)</code>.</p>

<p>When we get to multimethods, we&rsquo;ll see that linearization is trickier in multiple inheritance. The <a href="http://192.220.96.201/dylan/linearization-oopsla96.html">C3 linearization algorithm</a>, developed for <a href="http://www.opendylan.org/">Dylan</a>, is the canonical solution, I think, but it&rsquo;s not what I&rsquo;d call simple.</p>

<p>These problems are scary enough that language designers ran away. Java, C# and JavaScript only allow single inheritance. Other languages deal with this by providing limited forms of multiple inheritance. Ruby has mixins. Scala has traits.</p>

<h3>A Solution?</h3>

<p>After reading a bunch, I convinced myself that almost all of the problems with multiple inheritance come from there being multiple paths to the same base class. Duplicate state, ambiguous overrides, and even C3&rsquo;s complexity have a lot to do with inheriting the same class twice.</p>

<p>Why not just disallow that?</p>

<p>So my idea for Magpie was that you could inherit from multiple classes, but you could never inherit from the same class twice either directly or indirectly. In other words, the family tree leading to a given class must always be a <em>tree</em> and never a graph. No deadly diamond. Problem solved!</p>

<h3>The Root of the Problem</h3>

<p>Well, not quite. You see most OOP languages have a root class (the <a href="http://en.wikipedia.org/wiki/Top_type">top type</a> for you type system folks), usually called something like <code>Object</code>. This is the class that all classes inherit from. That means <em>every</em> class hierarchy is a graph: they always connect back to <code>Object</code> at the top.</p>

<p>We could just ditch that concept (C++ does), but a root class is really useful. There are some operations that are valid on pretty much everything. Think <code>toString()</code>, <code>getHashCode()</code>, and <code>equals()</code>. Without a root class, there&rsquo;s no place to hang methods like that.</p>

<p>I got stuck on this issue for months. In the meantime, I started learning more about multimethods.</p>

<h2>Multi-what?</h2>

<p>Multimethods, like <a href="http://en.wikipedia.org/wiki/Pattern_matching">pattern matching</a>, are a language puzzle to me. They are <em>so awesome</em> and yet so <em>few</em> languages support them. People are finally starting to catch on to pattern matching, but the set of languages that support multimethods can still fit in your hand: Common Lisp, through <a href="http://www.dreamsongs.com/CLOS.html">CLOS</a>, <a href="http://www.opendylan.org/">Dylan</a> (mostly dead but maybe being resurrected now?), and the still nascent <a href="http://slatelanguage.org/">Slate</a> language.</p>

<p>If you&rsquo;ve never heard of multimethods, the basic idea is pretty simple though a bit confusing if you come from a single-dispatch (i.e. C++, Java, C#, Smalltalk, et. al.) background. These languages do runtime dispatch only on the receiver, using the term &ldquo;overriding&rdquo;:</p>
<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span></span><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">method</span><span class="p">()</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Base!&quot;</span><span class="p">);</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">method</span><span class="p">()</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Derived!&quot;</span><span class="p">);</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Later...</span>
<span class="n">Base</span><span class="o">*</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">();</span>
<span class="n">obj</span><span class="o">-&gt;</span><span class="n">method</span><span class="p">();</span> <span class="c1">// prints &quot;Derived!&quot;</span>
</code></pre></div>
<p>The last line is the key bit. Even though <code>obj</code> is a pointer of type <code>Base</code>, at <em>runtime</em> it looks up the actual class of the object being pointed to and finds the right method for it.</p>

<p>This is in contrast with over<em>loading</em> which is only static in those languages. Let&rsquo;s see:</p>
<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span></span><span class="kt">void</span> <span class="nf">method</span><span class="p">(</span><span class="n">Base</span><span class="o">*</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Base!&quot;</span><span class="p">);</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">method</span><span class="p">(</span><span class="n">Derived</span><span class="o">*</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Derived!&quot;</span><span class="p">);</span> <span class="p">}</span>

<span class="c1">// Later...</span>
<span class="n">Base</span><span class="o">*</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">();</span>
<span class="n">method</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</code></pre></div>
<p>Does this also print <code>&quot;Derived!&quot;</code>? Alas, no. With function arguments, the overloaded function is chosen at <em>compile</em> time. Since the compiler only knows that <code>obj</code> is of type <code>Base*</code>, it binds the call to the version of <code>overloaded()</code> that expects that. At runtime, the actual class of the object that <code>obj</code> points to is ignored.</p>

<h3>The Receiver Argument</h3>

<p>When we see a chunk of code like <code>collection.add(&quot;item&quot;)</code>, we tend to think of <code>collection</code> and <code>&quot;item&quot;</code> as being fundamentally different from each other. But really, they&rsquo;re just two arguments being passed to <code>add()</code>. It&rsquo;s just that one happens to appear to the left of the method name. It could just as easily be <code>add(collection, &quot;item&quot;)</code> (which is exactly how it would be in C or Lisp more or less).</p>

<p>From that perspective, single dispatch seems weird. You&rsquo;ve got this special behavior that only applies to the first argument passed to every method (<code>this</code>), and the other arguments are second-class citizens.</p>

<p>Multiple dispatch fixes that. In a language with multiple dispatch, the <em>runtime</em> types of <em>all</em> arguments are used to select the actual method that gets called when given a set of overloads. If C++ supported multiple dispatch, then this&hellip;</p>
<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span></span><span class="kt">void</span> <span class="nf">method</span><span class="p">(</span><span class="n">Base</span><span class="o">*</span>   <span class="n">a</span><span class="p">,</span> <span class="n">Base</span><span class="o">*</span>   <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;base base&quot;</span><span class="p">);</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">method</span><span class="p">(</span><span class="n">Base</span><span class="o">*</span>   <span class="n">a</span><span class="p">,</span> <span class="n">Derived</span><span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;base derived&quot;</span><span class="p">);</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">method</span><span class="p">(</span><span class="n">Derived</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="n">Base</span><span class="o">*</span>   <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;derived base&quot;</span><span class="p">);</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">method</span><span class="p">(</span><span class="n">Derived</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="n">Derived</span><span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;derived derived&quot;</span><span class="p">);</span> <span class="p">}</span>

<span class="c1">// Later...</span>
<span class="n">Base</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">();</span>
<span class="n">Base</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">();</span>
<span class="n">method</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>
<p>&hellip;would print <code>&quot;derived derived&quot;</code> even though the <em>static</em> types of <code>a</code> and <code>b</code> are just <code>Base*</code>.</p>

<h3>What&rsquo;s the Problem?</h3>

<p>I&rsquo;ll give a stronger sales pitch for multiple dispatch later, but I hope you can see already that multiple dispatch is more general and more expressive than single dispatch. But it isn&rsquo;t easy.</p>

<p>The problem is what&rsquo;s called <em>linearization</em>. Given a set of overloaded methods (like our four examples above) and a set of actual arguments, which method wins and actually gets called?</p>

<p>In our example here, it&rsquo;s pretty obvious. Derived classes take precedence over base ones, so the derived-most overload wins. There are some pathological cases that are nasty, though:</p>
<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span></span><span class="kt">void</span> <span class="nf">method</span><span class="p">(</span><span class="n">Base</span><span class="o">*</span>   <span class="n">a</span><span class="p">,</span> <span class="n">Derived</span><span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;base derived&quot;</span><span class="p">);</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">method</span><span class="p">(</span><span class="n">Derived</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="n">Base</span><span class="o">*</span>   <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;derived base&quot;</span><span class="p">);</span> <span class="p">}</span>

<span class="c1">// Later...</span>
<span class="n">Base</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">();</span>
<span class="n">Base</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">();</span>
<span class="n">method</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>
<p>Which one should win? There really isn&rsquo;t a right answer here. I guess every time you call that method, the runtime would have to email the original author of the code and be all &ldquo;dude, what did you want this to do?&rdquo;</p>

<p>But ignoring pathological cases, linearization is still tricky, which a perusal of the C3 algorithm should convince you of. Take a look at some of the <a href="http://www.python.org/download/releases/2.3/mro/">explanatory examples that Python uses</a> and report back to me.</p>

<h2>You Scratch My Back, I&rsquo;ll Scratch Yours</h2>

<p>If you look at that Python page, you&rsquo;ll notice that most of the pathological examples have something in common: <em>multiple paths to the same base class.</em> The original problem with multiple inheritance is back!</p>

<p>But this is great news, because it means that our trick of not allowing inheriting the same class twice will also dramatically simplify linearization of multimethods.</p>

<p>Can multimethods in turn help us out with our root class problem? Indeed, they can! When you define a method in a language that supports multimethods, you provide a pattern that describes the arguments that method accepts. For example (finally switching to Magpie syntax), a method like this:</p>
<div class="highlight"><pre><code class="language-magpie" data-lang="magpie"><span></span><span class="k">def</span> <span class="n">overloaded</span><span class="p">(</span><span class="err">a</span> <span class="k">is</span> <span class="n">Base</span><span class="p">,</span> <span class="err">b</span> <span class="k">is</span> <span class="n">Derived</span><span class="p">)</span>
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;base derived&quot;</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<p>Will match a first argument of type <code>Base</code> (or a subclass of it) and a second of type <code>Derived</code> (again, or a subclass). They say that this method is <em>specialize</em> to those types.</p>

<p>But it isn&rsquo;t necessary to specialize an argument at all. A type pattern is just one kind of pattern. You can also define a method like this:</p>
<div class="highlight"><pre><code class="language-magpie" data-lang="magpie"><span></span><span class="k">def</span> <span class="n">overloaded</span><span class="p">(</span><span class="err">a</span><span class="p">,</span> <span class="err">b</span><span class="p">)</span>
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;who knows?!&quot;</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<p>Here, <code>a</code> and <code>b</code> aren&rsquo;t specialized to a class at all, which means this method matches <em>any</em> pair of arguments. A method that is applicable to an object of any class? Sounds an awful lot like what we&rsquo;d want something like <code>toString()</code> or <code>getHashCode()</code> to work on.</p>

<p>Problem solved. We don&rsquo;t need a root class. We&rsquo;ll just use unspecialized methods instead.</p>

<h2>The Core of a Language</h2>

<p>This is the new core of Magpie. Classes can inherit from multiple base classes, as long as there is no overlap, and all methods are defined outside of the class as multimethods. This is very close to how CLOS works. But there&rsquo;s a little sugar I&rsquo;ve added.</p>

<p>With multimethods, all arguments including the &ldquo;receiver&rdquo; are just regular arguments, so there&rsquo;s no special <code>this</code>. That implies just using a normal non-OOP-style function call syntax. For example, this in C++:</p>
<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span></span><span class="n">planner</span><span class="p">.</span><span class="n">getAddressBook</span><span class="p">().</span><span class="n">getPhoneNumbers</span><span class="p">().</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;867-5309&quot;</span><span class="p">);</span>
</code></pre></div>
<p>Would look something like this in CLOS:</p>
<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span></span><span class="p">(</span><span class="nv">add</span> <span class="p">(</span><span class="nv">get-phone-numbers</span> <span class="p">(</span><span class="nv">get-address-book</span> <span class="nv">planner</span><span class="p">))</span> <span class="s">&quot;867-5309&quot;</span><span class="p">)</span>
</code></pre></div>
<p>Maybe it&rsquo;s just me, but I find that hard to read. My experience is that most operations tend to have one argument that <em>is</em> kind of special. Putting it to the left of the operation makes it easier to read the code from left-to-right. It also gives a hint as to which arguments are likely to be most strongly affected by the call. So the above in Magpie would be:</p>
<div class="highlight"><pre><code class="language-magpie" data-lang="magpie"><span></span><span class="n">planner</span> <span class="n">addressBook</span> <span class="n">phoneNumbers</span> <span class="n">add</span><span class="p">(</span><span class="s">&quot;867-5309&quot;</span><span class="p">)</span>
</code></pre></div>
<p>Semantically, it&rsquo;s pure multiple dispatch. <em>Syntactically</em>, you can specify that an argument appears to the left of the method, to the right, or both. A getter, like <code>addressBook</code> in <code>planner addressBook</code> is just a method with one argument that appears to the left. A method call like <code>add</code> in <code>phoneNumbers add(&quot;867-5309&quot;)</code> has arguments on both sides. And a straight function call like <code>print(&quot;hi&quot;)</code> just has an argument to the right.</p>

<p>I&rsquo;m still poking at the syntax, but so far I really like it. You get flexibility over how your code reads but the uniform semantics of multiple dispatch.</p>

<h2>The Sales Pitch</h2>

<p>If you&rsquo;ve made it this far, I&rsquo;ll try to reward you. Through all of this, I haven&rsquo;t really shown what&rsquo;s cool about multimethods. Why go through all this trouble? Here&rsquo;s why&hellip;</p>

<h3>Overloading in a Dynamic Language</h3>

<p>Since most dynamic languages don&rsquo;t have any concept of annotating a method&rsquo;s expected types, that generally rules out the ability to overload at all. That&rsquo;s a shame since lots of methods are nicely defined in terms of optional arguments, or arguments of different types.</p>

<p>For a real world example, consider the magic <code>$()</code> function in <a href="http://jquery.com/">jQuery</a>. It&rsquo;s <a href="http://api.jquery.com/jQuery/">documented like this</a>:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>$(selector, [context])
selector      - A string containing a selector expression.
context       - A DOM Element, Document, or jQuery to use as
                context.

$(element)
element       - A DOM element to wrap in a jQuery object.

$(elementArray)
elementArray  - An array containing a set of DOM elements to
                wrap in a jQuery object.

$(jQuery object)
jQuery object - An existing jQuery object to clone.

$()
</code></pre></div>
<p>Those look an awful lot like overloads, which Javascript doesn&rsquo;t support. How do they do this? By making <a href="https://github.com/jquery/jquery/blob/master/src/core.js#L70">one monolithic function</a> with a slew of <code>instanceof</code> checks interspersed throughout it. Eek!</p>

<p>In Magpie you can just do:</p>
<div class="highlight"><pre><code class="language-magpie" data-lang="magpie"><span></span><span class="k">def</span> <span class="o">$</span><span class="p">(</span><span class="n">selector</span> <span class="k">is</span> <span class="n">String</span><span class="p">)</span> <span class="o">...</span>
<span class="k">def</span> <span class="o">$</span><span class="p">(</span><span class="n">selector</span> <span class="k">is</span> <span class="n">String</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span> <span class="o">...</span>
<span class="k">def</span> <span class="o">$</span><span class="p">(</span><span class="n">element</span> <span class="k">is</span> <span class="n">Element</span><span class="p">)</span> <span class="o">...</span>
<span class="k">def</span> <span class="o">$</span><span class="p">(</span><span class="n">elementArray</span> <span class="k">is</span> <span class="n">List</span><span class="p">)</span> <span class="o">...</span>
<span class="k">def</span> <span class="o">$</span><span class="p">(</span><span class="n">object</span> <span class="k">is</span> <span class="n">JQuery</span><span class="p">)</span> <span class="o">...</span>
<span class="k">def</span> <span class="o">$</span><span class="p">()</span> <span class="o">...</span>
</code></pre></div>
<p>The language itself will then take care of picking the appropriate method for you and doing all of the <code>instanceof</code> checks and variable binding itself. The nice thing about that is that it happens atomically. You don&rsquo;t have to worry about bugs where you <em>think</em> <code>selector</code> is a string, but you forgot the <code>instanceof</code> check. If it picks the first method up there, you know for certain <code>selector</code> will be a string.</p>

<h3>Binary Operators</h3>

<p>Magpie doesn&rsquo;t have built-in operators, so you&rsquo;re free to define your own and overload existing ones (but, for the love of God, please don&rsquo;t go <a href="http://jim-mcbeath.blogspot.com/2008/12/scala-operator-cheat-sheet.html">all Scala on it</a>). Multimethods are a big help here.</p>

<p>A simple example is <code>!=</code>. In C# and C++ when you overload <code>==</code>, you have to remember to also overload <code>!=</code> since that&rsquo;s also a method on the class you&rsquo;re overloading it for. In Magpie, a single definition of <code>!=</code> serves to cover all cases:</p>
<div class="highlight"><pre><code class="language-magpie" data-lang="magpie"><span></span><span class="k">def</span> <span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">right</span><span class="p">)</span>
    <span class="k">not</span><span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<p>Now if you overload <code>==</code>, you get <code>!=</code> for free.</p>

<p>Another example is <code>+</code>. Magpie uses it for both numeric addition and string contenation. Many languages have to build that directly into the language to get that overloading to work right. In Magpie, it&rsquo;s just:</p>
<div class="highlight"><pre><code class="language-magpie" data-lang="magpie"><span></span><span class="k">def</span> <span class="p">(</span><span class="n">left</span> <span class="k">is</span> <span class="n">Int</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="k">is</span> <span class="n">Int</span><span class="p">)</span> <span class="o">...</span>

<span class="k">def</span> <span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span><span class="p">)</span>
    <span class="n">concatenate</span><span class="p">(</span><span class="n">left</span> <span class="n">string</span><span class="p">,</span> <span class="n">right</span> <span class="n">string</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<p>If both arguments are ints, the first method wins and you get addition. Otherwise, it calls the <code>string</code> method on the two arguments and concatenates.</p>

<h3>Value Patterns</h3>

<p>We&rsquo;ve covered methods that specialize on types and ones that allow an argument of any type. There&rsquo;s another flavor of pattern too: <em>value patterns</em>. Those let you define methods that only match on specific argument values. Consider the venerable Fibonacci function. With value patterns, you can implement it like this:</p>
<div class="highlight"><pre><code class="language-magpie" data-lang="magpie"><span></span><span class="k">def</span> <span class="n">fib</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="mi">0</span>
<span class="k">def</span> <span class="n">fib</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="mi">1</span>
<span class="k">def</span> <span class="n">fib</span><span class="p">(</span><span class="err">n</span> <span class="k">is</span> <span class="n">Int</span><span class="p">)</span> <span class="n">fib</span><span class="p">(</span><span class="err">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="err">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div>
<p>Note that the order these are defined doesn&rsquo;t matter. The linearization algorithm takes care of picking the first two methods for those values of <code>n</code>: a value pattern always wins over a type pattern.</p>

<p>Value patterns turn out to be a perfect fit for a surprising problem: static methods. Most OOP languages let you define methods that don&rsquo;t work on an <em>instance</em> of a class, but instead on the class itself. In C++/C#/Java these are called &ldquo;static&rdquo;, for example:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="s">&quot;123&quot;</span><span class="o">);</span>
</code></pre></div>
<p>Static OOP languages handle this by having built-in special support for static methods. In Smalltalk, classes are <a href="http://en.wikipedia.org/wiki/First-class_object">first class</a>. That means a class is just another object you can pass around. It handles &ldquo;static&rdquo; methods by making them regular <em>instance</em> methods on the class <em>of the class object itself</em>: its <a href="http://www.ifi.uzh.ch/richter/Classes/oose2/05_Metaclasses/02_smalltalk/02_metaclasses_smalltalk.html">metaclass</a>.</p>

<p>That means for every class, (say <code>Int</code>) there&rsquo;s a corresponding metaclass (<code>IntMetaclass</code>). When you call a method on an int, like <code>123 sqrt()</code> it finds that method on the <code>Int</code> class. When you call a method on <code>Int</code> itself, like <code>Int parse(&quot;123&quot;)</code>, it finds that on the <em>meta</em>class.</p>

<p>Classes are first class in Magpie too, so it worked that way for a while. That meant making a pair of classes for each class and <a href="http://en.wikipedia.org/wiki/File:Smalltalk_80_metaclasses.svg">a fairly confusing metaclass hierarchy</a>.</p>

<p>With multimethods, that all <a href="https://github.com/munificent/magpie/commit/424b2724af47fffc426c1e432c8fae051ce3a0d1#L6L18">just goes away</a>. Instead, a &ldquo;static&rdquo; method is just a method that matches on a class <em>by value</em>:</p>
<div class="highlight"><pre><code class="language-magpie" data-lang="magpie"><span></span><span class="k">def</span> <span class="p">(</span><span class="o">==</span> <span class="n">Int</span><span class="p">)</span> <span class="n">parse</span><span class="p">(</span><span class="n">text</span> <span class="n">String</span><span class="p">)</span> <span class="o">...</span>
</code></pre></div>
<p>The <code>(== Int)</code> pattern here means we match on <code>Int</code> by value as opposed to <code>(is Int)</code> which means to match on it by type.</p>

<p>With that, I can ditch metaclasses completely. Things like constructors just become multimethods that specialize to class values for their left-hand argument.</p>

<h3>Safely Extensible Classes</h3>

<p>Finally, we get to the last bit, the real reason I wanted to add multimethods in the first place. Before I started working on Magpie, I spent most of my time in C#. One of my favorite features is <a href="http://journal.stuffwithstuff.com/2008/02/09/c-extension-methods-not-just-for-breakfast/">extension methods</a>. They give you the ability to effectively add new methods to a class without the horrors of monkey-patching.</p>

<p>My motivation is pretty mundane: I think method call syntax is the usually the most readable, and I care deeply about readability. I prefer this:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="n">list</span><span class="o">.</span><span class="na">reverse</span><span class="o">();</span>
</code></pre></div>
<p>Over this:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="n">Collections</span><span class="o">.</span><span class="na">reverse</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
</code></pre></div>
<p>But I want to avoid the chaos of monkey-patching. Multimethods are a neat solution to this. With multimethods, the methods aren&rsquo;t directly tied to classes at all. You&rsquo;re perfectly free to define a <code>reverse</code> method like this:</p>
<div class="highlight"><pre><code class="language-magpie" data-lang="magpie"><span></span><span class="k">def</span> <span class="p">(</span><span class="n">list</span> <span class="k">is</span> <span class="n">List</span><span class="p">)</span> <span class="n">reverse</span><span class="p">()</span> <span class="o">...</span>
</code></pre></div>
<p>And then you can call <code>reverse()</code> as it if were a native method on Lists. Because you aren&rsquo;t cracking open the class itself, this is nice and modular. Code that imports the module where you define that will get your <code>reverse()</code> method, and modules that don&rsquo;t won&rsquo;t. If they define their own <code>reverse()</code>, there&rsquo;s no collision. You could even access both within the same module by renaming when you import:</p>
<div class="highlight"><pre><code class="language-magpie" data-lang="magpie"><span></span><span class="k">import</span> <span class="n">bobs.list.methods</span> <span class="k">with</span>
    <span class="n">reverse</span> <span class="n">as</span> <span class="n">bobs.reverse</span>
<span class="k">end</span>
<span class="k">import</span> <span class="n">your.list.methods</span> <span class="k">with</span>
    <span class="n">reverse</span> <span class="n">as</span> <span class="n">your.reverse</span>
<span class="k">end</span>

<span class="k">var</span> <span class="n">list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">list</span> <span class="n">bobs.reverse</span><span class="p">()</span>
<span class="n">list</span> <span class="n">your.reverse</span><span class="p">()</span>
</code></pre></div>
<p>(Here, the <code>.</code> is just part of the method name. It looks funny at first, but hopefully not <em>too</em> funny.)</p>

<h2>What Now?</h2>

<p>I&rsquo;m still ironing out the kinks with all of this, but so far it looks pretty promising. It&rsquo;s nice to be able to define methods on whatever types you want, and I find multiple inheritance to be a refreshingly effective way to reuse code after years of dealing with single inheritance.</p>

<p>I&rsquo;ve still got lots of work and weird edge cases to deal with, though. The syntax for patterns and defining methods is OK but not ideal. There&rsquo;s a couple of ugly corner cases between how multimethods and modules interact.</p>

<p>The two biggest pieces are that in the process of doing this, I yanked a bunch of other code out. It was really hard to get this to work without breaking the other existing features so I just scrapped them. As of today, Magpie no longer has <a href="http://journal.stuffwithstuff.com/2011/02/13/extending-syntax-from-within-a-language">extensible syntax</a> or <a href="http://journal.stuffwithstuff.com/2010/10/29/bootstrapping-a-type-system/">static checking</a>, previously its two most interesting features. Oops!</p>

<p>Getting the syntax extension stuff working again won&rsquo;t be too much trouble. Getting the type system going again will be a bit of work. When I tore it out, I realized how much code was related just to that and how much complexity a static type system really adds to the language. When I add it back in, I&rsquo;ll try to keep all of that in Magpie (it used to be half Magpie, half directly in the interpreter).</p>

<p>A surprising thing I noticed is that multimethods actually cover some of the utility of static types. With them, I&rsquo;m still usually annotating the types that methods expect, which is nice for documentation, and I still get the guarantee that a method won&rsquo;t get an unexpected argument.</p>

<p>I still want to get a real type system (or multiple, which is a big motivation for defining it at the library level!) going too, but it&rsquo;s refreshing not having to deal with it for a while. One thing I&rsquo;ve learned in the past year is that designing a type system is about ten times harder than designing a language.</p>

  <div class="social">
    <a href="//www.reddit.com/submit?url=http://journal.stuffwithstuff.com/2011/04/21/multimethods-multiple-inheritance-multiawesome/" target="_blank">
      <i class="fa fa-lg fa-reddit-square"></i>
    </a>

    <a href="//news.ycombinator.com/submitlink?u=http://journal.stuffwithstuff.com/2011/04/21/multimethods-multiple-inheritance-multiawesome/&amp;t=Multimethods, Multiple Inheritance, Multiawesome!" target="_blank">
      <i class="fa fa-lg fa-hacker-news"></i>
    </a>

    <a href="http://twitter.com/share?url=http://journal.stuffwithstuff.com/2011/04/21/multimethods-multiple-inheritance-multiawesome&amp;text=%22Multimethods, Multiple Inheritance, Multiawesome!%22%20%40munificentbob" target="_blank">
      <i class="fa fa-lg fa-twitter-square"></i>
    </a>

    <a href="http://www.facebook.com/share.php?u=http://journal.stuffwithstuff.com/2011/04/21/multimethods-multiple-inheritance-multiawesome" target="_blank">
      <i class="fa fa-lg fa-facebook-square"></i>
    </a>

    <a href="https://plus.google.com/share?url=http://journal.stuffwithstuff.com/2011/04/21/multimethods-multiple-inheritance-multiawesome" target="_blank">
      <i class="fa fa-lg fa-google-plus-square"></i>
    </a>

    <a href="/rss.xml">
      <i class="fa fa-lg fa-rss-square"></i>
    </a>
  </div>

  
  <div class="comments">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'journal-stuffwithstuff';
        var disqus_url = "http://journal.stuffwithstuff.com/2011/04/21/multimethods-multiple-inheritance-multiawesome";

        (function() {
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
  
</article>


      <nav>
  <div class="nav-first">
    <a href="/"><img src="/image/dogshot_square.jpg" class="bob"></a>

    <p>Hi! I'm <strong>Bob Nystrom</strong>, the one on the left.</p>
    <p>I wrote a book called <a href="http://gameprogrammingpatterns.com/"><strong>Game Programming Patterns</strong></a>. I'm working on another book called
    <a href="http://craftinginterpreters.com">Crafting Interpreters</a></p>
    <p>You can email me at <code>robert</code> at this site or follow me on twitter at <a href="https://twitter.com/intent/user?screen_name=munificentbob"><code>@munificentbob</code></a>.</p>

    <h2>Elsewhere</h2>
    <ul>
      <li>Code at <a href="http://github.com/munificent">github</a></li>
      <li>Tweets at <a href="http://twitter.com/munificentbob">twitter</a></li>
      <li>Photos at <a href="https://500px.com/munificent">500px</a></li>
      <li>Photos at <a href="http://www.flickr.com/photos/bobisbob/">flickr</a></li>
    </ul>
  </div>
  <div class="nav-second">
    <h2>Categories</h2>
    <ul><li><a href="/category/code">code</a> <small class='post-count'>67</small></li><li><a href="/category/language">language</a> <small class='post-count'>41</small></li><li><a href="/category/magpie">magpie</a> <small class='post-count'>24</small></li><li><a href="/category/c-sharp">c-sharp</a> <small class='post-count'>13</small></li><li><a href="/category/dart">dart</a> <small class='post-count'>13</small></li><li><a href="/category/game-dev">game-dev</a> <small class='post-count'>12</small></li><li><a href="/category/java">java</a> <small class='post-count'>10</small></li><li><a href="/category/cpp">cpp</a> <small class='post-count'>8</small></li><li><a href="/category/game-patterns">game-patterns</a> <small class='post-count'>6</small></li><li><a href="/category/parsing">parsing</a> <small class='post-count'>6</small></li><li><a href="/category/roguelike">roguelike</a> <small class='post-count'>6</small></li><li><a href="/category/design">design</a> <small class='post-count'>5</small></li><li><a href="/category/go">go</a> <small class='post-count'>5</small></li><li><a href="/category/js">js</a> <small class='post-count'>4</small></li><li><a href="/category/book">book</a> <small class='post-count'>3</small></li><li><a href="/category/c">c</a> <small class='post-count'>3</small></li><li><a href="/category/finch">finch</a> <small class='post-count'>3</small></li><li><a href="/category/python">python</a> <small class='post-count'>3</small></li><li><a href="/category/ruby">ruby</a> <small class='post-count'>3</small></li><li><a href="/category/blog">blog</a> <small class='post-count'>2</small></li><li><a href="/category/f-sharp">f-sharp</a> <small class='post-count'>2</small></li><li><a href="/category/lua">lua</a> <small class='post-count'>2</small></li><li><a href="/category/music">music</a> <small class='post-count'>2</small></li><li><a href="/category/ai">ai</a> <small class='post-count'>1</small></li><li><a href="/category/beta">beta</a> <small class='post-count'>1</small></li><li><a href="/category/blogofile">blogofile</a> <small class='post-count'>1</small></li><li><a href="/category/game">game</a> <small class='post-count'>1</small></li><li><a href="/category/jasic">jasic</a> <small class='post-count'>1</small></li><li><a href="/category/javascript">javascript</a> <small class='post-count'>1</small></li><li><a href="/category/oop">oop</a> <small class='post-count'>1</small></li><li><a href="/category/optimization">optimization</a> <small class='post-count'>1</small></li><li><a href="/category/oscon">oscon</a> <small class='post-count'>1</small></li><li><a href="/category/politics">politics</a> <small class='post-count'>1</small></li><li><a href="/category/scheme">scheme</a> <small class='post-count'>1</small></li><li><a href="/category/typescript">typescript</a> <small class='post-count'>1</small></li><li><a href="/category/visualization">visualization</a> <small class='post-count'>1</small></li></ul>

    <p class="archive">All <a href="/archive">74 articles</a>&hellip;</p>

    <p>This blog is built using <a href="http://jekyllrb.com/">jekyll</a>. The source repo for it is <a href="https://github.com/munificent/journal">here</a>.</p>
    <p class="copyright">&copy; 2008-2014 Robert Nystrom</p>
  </div>
</nav>
    </div>
  </body>
</html>
