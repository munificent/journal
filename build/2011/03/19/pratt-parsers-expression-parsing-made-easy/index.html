<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Asap:ital,wght@0,100..900;1,100..900&family=IBM+Plex+Mono:ital,wght@0,400;0,600&family=Petrona:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">

  <!-- Tell mobile browsers we're optimized for them and they don't need to
       crop the viewport. -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/rss.xml" />
  <link rel="alternate" type="application/atom+xml" title="Atom 1.0" href="/atom.xml" />

  <!-- Styles -->
  <link rel="stylesheet" href="/style.css" type="text/css" />

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  <link rel="shortcut icon" href="/favicon.ico" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
  <link rel="manifest" href="/site.webmanifest" />

  <title>
    Pratt Parsers: Expression Parsing Made Easy &ndash; journal.stuffwithstuff.com
  </title>

  <script src="/aside.js"></script>
</head>  <body>
    <main>
<header>
  <a href="/">journal.stuffwithstuff.com</a>
  <a class="about" href="#footer">â†“ about me</a>
</header>
<div class="post-thread">
    <div>
      <a href="/2011/02/21/multiple-inheritance-in-javascript/"
         title="Older Post &ldquo;Multiple Inheritance in JavaScript&rdquo;">&lt; prev</a>
    </div>
  <div>
    <a href="/archive">archive</a>
  </div>
    <div>
      <a href="/2011/04/21/multimethods-multiple-inheritance-multiawesome/"
         title="Newer Post &ldquo;Multimethods, Multiple Inheritance, Multiawesome!&rdquo;">next &gt;</a>
    </div>
</div>
<article>
<h1>
  <a href="/2011/03/19/pratt-parsers-expression-parsing-made-easy/" rel="bookmark"
     title="Permanent Link to Pratt Parsers: Expression Parsing Made Easy">
    Pratt Parsers: Expression Parsing Made Easy
  </a>
</h1>
<nav>
  <div class="date">
    <span class="thread-narrow"><a href="/2011/02/21/multiple-inheritance-in-javascript/"
       title="Older Post &ldquo;Multiple Inheritance in JavaScript&rdquo;">&lt;</a></span>
    <a href="/archive">march 19, 2011</a>
    <span class="thread-narrow"><a href="/2011/04/21/multimethods-multiple-inheritance-multiawesome/"
       title="Newer Post &ldquo;Multimethods, Multiple Inheritance, Multiawesome!&rdquo;">&gt;</a></span>
  </div>
  <div class="tags">
      <a href="/category/code">code</a>
     |
      <a href="/category/java">java</a>
     |
      <a href="/category/js">js</a>
     |
      <a href="/category/language">language</a>
     |
      <a href="/category/magpie">magpie</a>
     |
      <a href="/category/parsing">parsing</a>
      </div>
</nav>
<p>Every now and then, I stumble onto some algorithm or idea that&rsquo;s so clever and
such a perfect solution to a problem that I feel like I got smarter or gained <a href="http://xkcd.com/208/">a
new superpower</a> just by learning it. <a href="http://en.wikipedia.org/wiki/Heap_%28data_structure%29">Heaps</a> were one, just about the
only thing I got out of my truncated CS education. I recently stumbled onto
another: <a href="http://en.wikipedia.org/wiki/Vaughan_Pratt">Pratt</a> or &ldquo;top-down operator precedence&rdquo; parsers.</p>
<p>When you&rsquo;re writing a parser, <a href="http://en.wikipedia.org/wiki/Recursive_descent">recursive descent</a> is as easy as spreading
peanut butter. It excels when you can figure out what to parse based on the next
bit of code you&rsquo;re looking at. That&rsquo;s usually true at the declaration and
statement levels of a language&rsquo;s grammar since most syntax there starts with
keywords&mdash;<code>class</code>, <code>if</code>, <code>for</code>, <code>while</code>, etc.</p>
<p>Parsing gets trickier when you get to expressions. When it comes to infix
operators like <code>+</code>, postfix ones like <code>++</code>, and even mixfix expressions like
<code>?:</code>, it can be hard to tell what kind of expression you&rsquo;re parsing until you&rsquo;re
halfway through it. You <em>can</em> do this with recursive descent, but it&rsquo;s a chore.
You have to write separate functions for each level of precedence (JavaScript
has 17 of them, for example), manually handle associativity, and smear your
grammar across a bunch of parsing code until it&rsquo;s hard to see.</p>
<h2 id="peanut-butter-and-jelly-the-secret-weapon"><a href="#peanut-butter-and-jelly-the-secret-weapon">Peanut butter and jelly, the secret weapon<span class="anchor">#peanut-butter-and-jelly-the-secret-weapon</span></a></h2>
<p>Pratt parsing solves that. If recursive descent is peanut butter, Pratt parsing
is the jelly. When you mix the two together, you get a simple, terse, readable
parser that can handle any grammar you throw at it.</p>
<p>Pratt&rsquo;s technique for handling operator precedence and infix expressions is so
simple and effective it&rsquo;s a mystery why almost no one knows about it. After the
seventies, top down operator precedence parsers seem to have fallen off the
Earth. Douglas Crockford&rsquo;s <a href="http://www.jslint.com/">JSLint</a> uses one to <a href="http://crockford.com/javascript/tdop/tdop.html">parse JavaScript</a>, but
his treatment is one of the <a href="http://effbot.org/zone/simple-top-down-parsing.htm">very few</a> remotely modern articles about
it.</p>
<p>Part of the problem, I think, is that Pratt&rsquo;s terminology is opaque, and
Crockford&rsquo;s article is itself rather murky. Pratt uses terms like &ldquo;null
denominator&rdquo; and Crockford mixes in extra stuff like tracking lexical scope that
obscures the core idea.</p>
<p>This is where I come in. I won&rsquo;t do anything revolutionary. I&rsquo;ll just try to get
the core concepts behind top down operator precedence parsers and present them
as clearly as I can. I&rsquo;ll switch out some terms to (I hope) clarify things.
Hopefully I won&rsquo;t offend anyone&rsquo;s purist sensibilities. I&rsquo;ll be coding in Java,
the vulgar Latin of programming languages. I figure if you can write it in Java,
you can write it in anything.</p>
<h2 id="what-well-be-making"><a href="#what-well-be-making">What we&rsquo;ll be making<span class="anchor">#what-well-be-making</span></a></h2>
<p>I&rsquo;m a learn-by-doing person, which means I&rsquo;m also a teach-by-doing one. So to
show how Pratt parsers work, we&rsquo;ll build a parser for a <a href="https://github.com/munificent/bantam">tiny little toy
language called <em>Bantam</em></a>. The language only has expressions since
that&rsquo;s where Pratt parsing is really helpful, but that should be enough to
convince you of its usefulness.</p>
<p>Even though Bantam is simple, it has a full gamut of operators: prefix (<code>+</code>,
<code>-</code>, <code>~</code>, <code>!</code>), postfix (<code>!</code>), infix (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>), and even a
mixfix conditional operator (<code>?:</code>). It has multiple precedence levels and both
right and left associative operators. It also has assignment, function calls and
parentheses for grouping. If we can parse this, we can parse anything.</p>
<h2 id="what-well-start-with"><a href="#what-well-start-with">What we&rsquo;ll start with<span class="anchor">#what-well-start-with</span></a></h2>
<p>All we care about is parsing, so we&rsquo;ll ignore the tokenizing phase. I slapped
together <a href="https://github.com/munificent/bantam/blob/master/src/com/stuffwithstuff/bantam/Lexer.java">a crude lexer</a> that works and we&rsquo;ll just pretend that tokens
are raining down from heaven or something.</p>
<p>A token is the smallest chunk of meaningful code. It has a type and a string
associated with it. Given <code>from + offset(time)</code>, the tokens would be:</p>
<pre class="highlight language-text">NAME &quot;from&quot;
PLUS &quot;+&quot;
NAME &quot;offset&quot;
LEFT_PAREN &quot;(&quot;
NAME &quot;time&quot;
RIGHT_PAREN &quot;)&quot;</pre>
<p>For this exercise, we won&rsquo;t be <em>interpreting</em> or <em>compiling</em> this code. We just
want to parse it to a nice data structure. For our purposes, that means our
parser should chew up a bunch of <a href="https://github.com/munificent/bantam/blob/master/src/com/stuffwithstuff/bantam/Token.java">Token</a> objects and spit out an instance
of some class that implements <a href="https://github.com/munificent/bantam/blob/master/src/com/stuffwithstuff/bantam/expressions/Expression.java">Expression</a>. To give you an idea,
here&rsquo;s a simplified version of the class for a <a href="https://github.com/munificent/bantam/blob/master/src/com/stuffwithstuff/bantam/expressions/ConditionalExpression.java">conditional expression</a>:</p>
<pre class="highlight language-java"><span class="k">class</span> <span class="t">ConditionalExpression</span> <span class="k">implements</span> <span class="t">Expression</span> <span class="p">{</span>
  <span class="k">public</span> <span class="t">ConditionalExpression</span><span class="p">(</span>
      <span class="t">Expression</span> <span class="i">condition</span><span class="p">,</span>
      <span class="t">Expression</span> <span class="i">thenArm</span><span class="p">,</span>
      <span class="t">Expression</span> <span class="i">elseArm</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="i">condition</span> <span class="o">=</span> <span class="i">condition</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="i">thenArm</span>   <span class="o">=</span> <span class="i">thenArm</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="i">elseArm</span>   <span class="o">=</span> <span class="i">elseArm</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">final</span> <span class="t">Expression</span> <span class="i">condition</span><span class="p">;</span>
  <span class="k">public</span> <span class="k">final</span> <span class="t">Expression</span> <span class="i">thenArm</span><span class="p">;</span>
  <span class="k">public</span> <span class="k">final</span> <span class="t">Expression</span> <span class="i">elseArm</span><span class="p">;</span>
<span class="p">}</span></pre>
<p>(You gotta love Java&rsquo;s &ldquo;please sign it in quadruplicate&rdquo; level of bureaucracy
here. Like I said, if you can tolerate this in Java, it can work in <em>any</em>
language.)</p>
<p>We&rsquo;ll start from a simple <a href="https://github.com/munificent/bantam/blob/master/src/com/stuffwithstuff/bantam/Parser.java">Parser</a> class. The parser owns the token
stream, handles lookahead and provides the basic methods you need to write a
top-down recursive descent parser with a single token of lookahead (it&rsquo;s
<a href="https://en.wikipedia.org/wiki/LL_parser">LL(1)</a>). This is enough to get us going. If we need more later, it&rsquo;s easy to
extend it.</p>
<p>OK, let&rsquo;s build ourselves a parser!</p>
<h2 id="first-things-first"><a href="#first-things-first">First things first<span class="anchor">#first-things-first</span></a></h2>
<p>Even though a &ldquo;full&rdquo; Pratt parser is pretty tiny, I found it to be hard to
decipher. Sort of like <a href="http://en.wikipedia.org/wiki/Quicksort">quicksort</a>, the implementation is a deceptively simple
handful of deeply intertwined code. To untangle it, we&rsquo;ll build it up one tiny
step at a time.</p>
<p>The simplest expressions to parse are prefix operators and single-token
expressions. For those, the current token tells us everything we need to do.
Bantam has one single-token expression: named variables. It has four prefix
operators: <code>+</code>, <code>-</code>, <code>~</code>, and <code>!</code>. The simplest possible code to parse those is:</p>
<pre class="highlight language-java"><span class="t">Expression</span> <span class="i">parseExpression</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="i">match</span><span class="p">(</span><span class="t">TokenType</span><span class="p">.</span><span class="i">NAME</span><span class="p">))</span>       <span class="c">// Return NameExpression...</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="i">match</span><span class="p">(</span><span class="t">TokenType</span><span class="p">.</span><span class="i">PLUS</span><span class="p">))</span>  <span class="c">// Return prefix + operator...</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="i">match</span><span class="p">(</span><span class="t">TokenType</span><span class="p">.</span><span class="i">MINUS</span><span class="p">))</span> <span class="c">// Return prefix - operator...</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="i">match</span><span class="p">(</span><span class="t">TokenType</span><span class="p">.</span><span class="i">TILDE</span><span class="p">))</span> <span class="c">// Return prefix ~ operator...</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="i">match</span><span class="p">(</span><span class="t">TokenType</span><span class="p">.</span><span class="i">BANG</span><span class="p">))</span>  <span class="c">// Return prefix ! operator...</span>
  <span class="k">else</span> <span class="k">throw</span> <span class="k">new</span> <span class="t">ParseException</span><span class="p">();</span>
<span class="p">}</span></pre>
<p>But that&rsquo;s a bit monolithic. As you can see, we&rsquo;re switching off of a TokenType
to branch to different parsing behavior. Let&rsquo;s encode that directly by making a
Map from TokenTypes to chunks of parsing code. We&rsquo;ll call these chunks
&ldquo;parselets&rdquo;, and they will implement this:</p>
<pre class="highlight language-java"><span class="k">interface</span> <span class="t">PrefixParselet</span> <span class="p">{</span>
  <span class="t">Expression</span> <span class="i">parse</span><span class="p">(</span><span class="t">Parser</span> <span class="i">parser</span><span class="p">,</span> <span class="t">Token</span> <span class="i">token</span><span class="p">);</span>
<span class="p">}</span></pre>
<p>An parselet implementation to parse variable names is simply:</p>
<pre class="highlight language-java"><span class="k">class</span> <span class="t">NameParselet</span> <span class="k">implements</span> <span class="t">PrefixParselet</span> <span class="p">{</span>
  <span class="k">public</span> <span class="t">Expression</span> <span class="i">parse</span><span class="p">(</span><span class="t">Parser</span> <span class="i">parser</span><span class="p">,</span> <span class="t">Token</span> <span class="i">token</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="t">NameExpression</span><span class="p">(</span><span class="i">token</span><span class="p">.</span><span class="i">getText</span><span class="p">());</span>
  <span class="p">}</span>
<span class="p">}</span></pre>
<p>We can use a single class for all of the prefix operators since they only differ
in the actual operator token itself:</p>
<pre class="highlight language-java"><span class="k">class</span> <span class="t">PrefixOperatorParselet</span> <span class="k">implements</span> <span class="t">PrefixParselet</span> <span class="p">{</span>
  <span class="k">public</span> <span class="t">Expression</span> <span class="i">parse</span><span class="p">(</span><span class="t">Parser</span> <span class="i">parser</span><span class="p">,</span> <span class="t">Token</span> <span class="i">token</span><span class="p">)</span> <span class="p">{</span>
    <span class="t">Expression</span> <span class="i">operand</span> <span class="o">=</span> <span class="i">parser</span><span class="p">.</span><span class="i">parseExpression</span><span class="p">();</span>
    <span class="k">return</span> <span class="k">new</span> <span class="t">PrefixExpression</span><span class="p">(</span><span class="i">token</span><span class="p">.</span><span class="i">getType</span><span class="p">(),</span> <span class="i">operand</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></pre>
<p>You&rsquo;ll note that it calls back into <code>parseExpression()</code> to parse the operand
that appears after the operator (for example, to parse the <code>a</code> in <code>-a</code>). This
recursion takes care of nested operators like <code>-+~!a</code>.</p>
<p>Back in Parser, the chained <code>if</code> statements are replaced with a map:</p>
<pre class="highlight language-java"><span class="k">class</span> <span class="t">Parser</span> <span class="p">{</span>
  <span class="k">public</span> <span class="t">Expression</span> <span class="i">parseExpression</span><span class="p">()</span> <span class="p">{</span>
    <span class="t">Token</span> <span class="i">token</span> <span class="o">=</span> <span class="i">consume</span><span class="p">();</span>
    <span class="t">PrefixParselet</span> <span class="i">prefix</span> <span class="o">=</span> <span class="i">mPrefixParselets</span><span class="p">.</span><span class="i">get</span><span class="p">(</span><span class="i">token</span><span class="p">.</span><span class="i">getType</span><span class="p">());</span>

    <span class="k">if</span> <span class="p">(</span><span class="i">prefix</span> <span class="o">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="t">ParseException</span><span class="p">(</span>
        <span class="s">&quot;Could not parse </span><span class="e">\&quot;</span><span class="s">&quot;</span> <span class="o">+</span> <span class="i">token</span><span class="p">.</span><span class="i">getText</span><span class="p">()</span> <span class="o">+</span> <span class="s">&quot;</span><span class="e">\&quot;</span><span class="s">.&quot;</span><span class="p">);</span>

    <span class="k">return</span> <span class="i">prefix</span><span class="p">.</span><span class="i">parse</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="i">token</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c">// Other stuff...</span>

  <span class="k">private</span> <span class="k">final</span> <span class="t">Map</span><span class="o">&lt;</span><span class="t">TokenType</span><span class="p">,</span> <span class="t">PrefixParselet</span><span class="o">&gt;</span> <span class="i">mPrefixParselets</span> <span class="o">=</span>
      <span class="k">new</span> <span class="t">HashMap</span><span class="o">&lt;</span><span class="t">TokenType</span><span class="p">,</span> <span class="t">PrefixParselet</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span></pre>
<p>To define the grammar we have so far&mdash;variables and the four prefix
operators&mdash;we&rsquo;ll add these helper methods:</p>
<pre class="highlight language-java"><span class="k">public</span> <span class="t">void</span> <span class="i">register</span><span class="p">(</span><span class="t">TokenType</span> <span class="i">token</span><span class="p">,</span> <span class="t">PrefixParselet</span> <span class="i">parselet</span><span class="p">)</span> <span class="p">{</span>
  <span class="i">mPrefixParselets</span><span class="p">.</span><span class="i">put</span><span class="p">(</span><span class="i">token</span><span class="p">,</span> <span class="i">parselet</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span> <span class="t">void</span> <span class="i">prefix</span><span class="p">(</span><span class="t">TokenType</span> <span class="i">token</span><span class="p">)</span> <span class="p">{</span>
  <span class="i">register</span><span class="p">(</span><span class="i">token</span><span class="p">,</span> <span class="k">new</span> <span class="t">PrefixOperatorParselet</span><span class="p">());</span>
<span class="p">}</span></pre>
<p>And now we can define the grammar like:</p>
<pre class="highlight language-java"><span class="i">register</span><span class="p">(</span><span class="t">TokenType</span><span class="p">.</span><span class="i">NAME</span><span class="p">,</span> <span class="k">new</span> <span class="t">NameParselet</span><span class="p">());</span>
<span class="i">prefix</span><span class="p">(</span><span class="t">TokenType</span><span class="p">.</span><span class="i">PLUS</span><span class="p">);</span>
<span class="i">prefix</span><span class="p">(</span><span class="t">TokenType</span><span class="p">.</span><span class="i">MINUS</span><span class="p">);</span>
<span class="i">prefix</span><span class="p">(</span><span class="t">TokenType</span><span class="p">.</span><span class="i">TILDE</span><span class="p">);</span>
<span class="i">prefix</span><span class="p">(</span><span class="t">TokenType</span><span class="p">.</span><span class="i">BANG</span><span class="p">);</span></pre>
<p>This is already an improvement over a recursive descent parser because our
grammar is now more declarative instead of being spread out over a few
imperative functions, and we can see the actual grammar all in one place. Even
better, we can extend the grammar just by registering new parselets. We don&rsquo;t
have to change the Parser class itself.</p>
<p>If we <em>only</em> had prefix expressions, we&rsquo;d be done now. Alas, we don&rsquo;t.</p>
<h2 id="stuck-in-the-middle"><a href="#stuck-in-the-middle">Stuck in the middle<span class="anchor">#stuck-in-the-middle</span></a></h2>
<p>What we have so far only works if the <em>first</em> token tells us what kind of
expression we&rsquo;re parsing, but that isn&rsquo;t always the case. With an expression
like <code>a + b</code>, we don&rsquo;t know we have an add expression until after we parse the
<code>a</code> and get to <code>+</code>. We have to extend the parser to support that.</p>
<p>Fortunately, we&rsquo;re in a good place to do so. Our current <code>parseExpression()</code>
method parses a complete prefix expression including any nested prefix
expressions and then stops. So, if we throw this at it:</p>
<pre class="highlight language-java"><span class="o">-</span><span class="i">a</span> <span class="o">+</span> <span class="i">b</span></pre>
<p>It will parse <code>-a</code> and leave us sitting on <code>+</code>. That&rsquo;s exactly the token we need
to tell what infix expression we need to parse. Compared to prefix parsing, the
only change for infix parsing is that there&rsquo;s another expression <em>before</em> the
infix operator that the infix parser receives as an argument. Let&rsquo;s define a
parselet that supports that:</p>
<pre class="highlight language-java"><span class="k">interface</span> <span class="t">InfixParselet</span> <span class="p">{</span>
  <span class="t">Expression</span> <span class="i">parse</span><span class="p">(</span><span class="t">Parser</span> <span class="i">parser</span><span class="p">,</span> <span class="t">Expression</span> <span class="i">left</span><span class="p">,</span> <span class="t">Token</span> <span class="i">token</span><span class="p">);</span>
<span class="p">}</span></pre>
<p>The only difference is that <code>left</code> argument, which is the expression we parsed
before we got to the infix token. We wire this up to our parser by having
another table of infix parselets.</p>
<p>Having separate tables for prefix and infix expressions is important because we
sometimes have both a prefix and infix parselet for the same TokenType. For
example, the prefix parselet for <code>(</code> handles grouping in an expression like <code>a * (b + c)</code>. Meanwhile, the <em>infix</em> parselet for <code>(</code> handles function calls like
<code>a(b)</code>.</p>
<p>Now, after we parse the leading prefix expression, we look for an infix parser
that matches the next token and wraps the prefix expression as an operand:</p>
<pre class="highlight language-java"><span class="k">class</span> <span class="t">Parser</span> <span class="p">{</span>
  <span class="k">public</span> <span class="t">void</span> <span class="i">register</span><span class="p">(</span><span class="t">TokenType</span> <span class="i">token</span><span class="p">,</span> <span class="t">InfixParselet</span> <span class="i">parselet</span><span class="p">)</span> <span class="p">{</span>
    <span class="i">mInfixParselets</span><span class="p">.</span><span class="i">put</span><span class="p">(</span><span class="i">token</span><span class="p">,</span> <span class="i">parselet</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="t">Expression</span> <span class="i">parseExpression</span><span class="p">()</span> <span class="p">{</span>
    <span class="t">Token</span> <span class="i">token</span> <span class="o">=</span> <span class="i">consume</span><span class="p">();</span>
    <span class="t">PrefixParselet</span> <span class="i">prefix</span> <span class="o">=</span> <span class="i">mPrefixParselets</span><span class="p">.</span><span class="i">get</span><span class="p">(</span><span class="i">token</span><span class="p">.</span><span class="i">getType</span><span class="p">());</span>

    <span class="k">if</span> <span class="p">(</span><span class="i">prefix</span> <span class="o">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="t">ParseException</span><span class="p">(</span>
        <span class="s">&quot;Could not parse </span><span class="e">\&quot;</span><span class="s">&quot;</span> <span class="o">+</span> <span class="i">token</span><span class="p">.</span><span class="i">getText</span><span class="p">()</span> <span class="o">+</span> <span class="s">&quot;</span><span class="e">\&quot;</span><span class="s">.&quot;</span><span class="p">);</span>

    <span class="t">Expression</span> <span class="i">left</span> <span class="o">=</span> <span class="i">prefix</span><span class="p">.</span><span class="i">parse</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="i">token</span><span class="p">);</span>

    <span class="i">token</span> <span class="o">=</span> <span class="i">lookAhead</span><span class="p">(</span><span class="n">0</span><span class="p">);</span>
    <span class="t">InfixParselet</span> <span class="i">infix</span> <span class="o">=</span> <span class="i">mInfixParselets</span><span class="p">.</span><span class="i">get</span><span class="p">(</span><span class="i">token</span><span class="p">.</span><span class="i">getType</span><span class="p">());</span>

    <span class="c">// No infix expression at this point, so we&#39;re done.</span>
    <span class="k">if</span> <span class="p">(</span><span class="i">infix</span> <span class="o">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">return</span> <span class="i">left</span><span class="p">;</span>

    <span class="i">consume</span><span class="p">();</span>
    <span class="k">return</span> <span class="i">infix</span><span class="p">.</span><span class="i">parse</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="i">left</span><span class="p">,</span> <span class="i">token</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c">// Other stuff...</span>

  <span class="k">private</span> <span class="k">final</span> <span class="t">Map</span><span class="o">&lt;</span><span class="t">TokenType</span><span class="p">,</span> <span class="t">InfixParselet</span><span class="o">&gt;</span> <span class="i">mInfixParselets</span> <span class="o">=</span>
      <span class="k">new</span> <span class="t">HashMap</span><span class="o">&lt;</span><span class="t">TokenType</span><span class="p">,</span> <span class="t">InfixParselet</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span></pre>
<p>Pretty straightforward. We can implement an infix parselet for binary arithmetic
operators like <code>+</code> like so:</p>
<pre class="highlight language-java"><span class="k">class</span> <span class="t">BinaryOperatorParselet</span> <span class="k">implements</span> <span class="t">InfixParselet</span> <span class="p">{</span>
  <span class="k">public</span> <span class="t">Expression</span> <span class="i">parse</span><span class="p">(</span><span class="t">Parser</span> <span class="i">parser</span><span class="p">,</span>
      <span class="t">Expression</span> <span class="i">left</span><span class="p">,</span> <span class="t">Token</span> <span class="i">token</span><span class="p">)</span> <span class="p">{</span>
    <span class="t">Expression</span> <span class="i">right</span> <span class="o">=</span> <span class="i">parser</span><span class="p">.</span><span class="i">parseExpression</span><span class="p">();</span>
    <span class="k">return</span> <span class="k">new</span> <span class="t">OperatorExpression</span><span class="p">(</span><span class="i">left</span><span class="p">,</span> <span class="i">token</span><span class="p">.</span><span class="i">getType</span><span class="p">(),</span> <span class="i">right</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></pre>
<p>Infix parselets also works for postfix operators. I&rsquo;m calling them &ldquo;infix&rdquo;, but
they&rsquo;re really &ldquo;anything but prefix&rdquo;. If there&rsquo;s some leading subexpression that
comes before the token, the token will be handled by an infix parselet. That
includes postfix expressions and mixfix ones like <code>?:</code>.</p>
<p>Postfix expressions are as simple as single-token prefix parselets: they just
take the <code>left</code> operand and wraps it in another expression:</p>
<pre class="highlight language-java"><span class="k">class</span> <span class="t">PostfixOperatorParselet</span> <span class="k">implements</span> <span class="t">InfixParselet</span> <span class="p">{</span>
  <span class="k">public</span> <span class="t">Expression</span> <span class="i">parse</span><span class="p">(</span><span class="t">Parser</span> <span class="i">parser</span><span class="p">,</span> <span class="t">Expression</span> <span class="i">left</span><span class="p">,</span>
      <span class="t">Token</span> <span class="i">token</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="t">PostfixExpression</span><span class="p">(</span><span class="i">left</span><span class="p">,</span> <span class="i">token</span><span class="p">.</span><span class="i">getType</span><span class="p">());</span>
  <span class="p">}</span>
<span class="p">}</span></pre>
<p>Mixfix is easy too. It&rsquo;s similar to recursive descent:</p>
<pre class="highlight language-java"><span class="k">class</span> <span class="t">ConditionalParselet</span> <span class="k">implements</span> <span class="t">InfixParselet</span> <span class="p">{</span>
  <span class="k">public</span> <span class="t">Expression</span> <span class="i">parse</span><span class="p">(</span><span class="t">Parser</span> <span class="i">parser</span><span class="p">,</span> <span class="t">Expression</span> <span class="i">left</span><span class="p">,</span>
      <span class="t">Token</span> <span class="i">token</span><span class="p">)</span> <span class="p">{</span>
    <span class="t">Expression</span> <span class="i">thenArm</span> <span class="o">=</span> <span class="i">parser</span><span class="p">.</span><span class="i">parseExpression</span><span class="p">();</span>
    <span class="i">parser</span><span class="p">.</span><span class="i">consume</span><span class="p">(</span><span class="t">TokenType</span><span class="p">.</span><span class="i">COLON</span><span class="p">);</span>
    <span class="t">Expression</span> <span class="i">elseArm</span> <span class="o">=</span> <span class="i">parser</span><span class="p">.</span><span class="i">parseExpression</span><span class="p">();</span>

    <span class="k">return</span> <span class="k">new</span> <span class="t">ConditionalExpression</span><span class="p">(</span><span class="i">left</span><span class="p">,</span> <span class="i">thenArm</span><span class="p">,</span> <span class="i">elseArm</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></pre>
<p>Now we can parse prefix, postfix, infix, and even mixfix expressions. With a
pretty small amount of code, we can parse complex nested expressions like <code>a + (b ? c! : -d)</code>. We&rsquo;re done, right? Well&hellip; almost.</p>
<h2 id="excuse-you-aunt-sally"><a href="#excuse-you-aunt-sally">Excuse you, aunt Sally<span class="anchor">#excuse-you-aunt-sally</span></a></h2>
<p>Our parser <em>can</em> parse all of this stuff, but it doesn&rsquo;t parse it with the right
precedence or associativity. If you throw <code>a - b - c</code> at the parser, it will
parse the nested expressions like <code>a - (b - c)</code>, which isn&rsquo;t right. (Well,
actually it is <em>right</em>&mdash;associative that is. We need it to be <em>left</em>.)</p>
<p>And this <em>last</em> step where we fix that is where Pratt parsers go from pretty
nice to totally radical. We&rsquo;ll make two simple changes. We extend
<code>parseExpression()</code> to take a <em>precedence</em>&mdash;a number that tells which
expressions can be parsed by that call. If <code>parseExpression()</code> encounters an
expression whose precedence is lower than we allow, it stops parsing and returns
what it has so far.</p>
<p>To make that check we need to know the precedence of any given infix
expression. We&rsquo;ll let the parselet specify it:</p>
<pre class="highlight language-java"><span class="k">public</span> <span class="k">interface</span> <span class="t">InfixParselet</span> <span class="p">{</span>
  <span class="t">Expression</span> <span class="i">parse</span><span class="p">(</span><span class="t">Parser</span> <span class="i">parser</span><span class="p">,</span> <span class="t">Expression</span> <span class="i">left</span><span class="p">,</span> <span class="t">Token</span> <span class="i">token</span><span class="p">);</span>
  <span class="t">int</span> <span class="i">getPrecedence</span><span class="p">();</span>
<span class="p">}</span></pre>
<p>Using that, our core expression parser looks like this:</p>
<pre class="highlight language-java"><span class="k">public</span> <span class="t">Expression</span> <span class="i">parseExpression</span><span class="p">(</span><span class="t">int</span> <span class="i">precedence</span><span class="p">)</span> <span class="p">{</span>
  <span class="t">Token</span> <span class="i">token</span> <span class="o">=</span> <span class="i">consume</span><span class="p">();</span>
  <span class="t">PrefixParselet</span> <span class="i">prefix</span> <span class="o">=</span> <span class="i">mPrefixParselets</span><span class="p">.</span><span class="i">get</span><span class="p">(</span><span class="i">token</span><span class="p">.</span><span class="i">getType</span><span class="p">());</span>

  <span class="k">if</span> <span class="p">(</span><span class="i">prefix</span> <span class="o">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="t">ParseException</span><span class="p">(</span>
      <span class="s">&quot;Could not parse </span><span class="e">\&quot;</span><span class="s">&quot;</span> <span class="o">+</span> <span class="i">token</span><span class="p">.</span><span class="i">getText</span><span class="p">()</span> <span class="o">+</span> <span class="s">&quot;</span><span class="e">\&quot;</span><span class="s">.&quot;</span><span class="p">);</span>

  <span class="t">Expression</span> <span class="i">left</span> <span class="o">=</span> <span class="i">prefix</span><span class="p">.</span><span class="i">parse</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="i">token</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="i">precedence</span> <span class="o">&lt;</span> <span class="i">getPrecedence</span><span class="p">())</span> <span class="p">{</span>
    <span class="i">token</span> <span class="o">=</span> <span class="i">consume</span><span class="p">();</span>

    <span class="t">InfixParselet</span> <span class="i">infix</span> <span class="o">=</span> <span class="i">mInfixParselets</span><span class="p">.</span><span class="i">get</span><span class="p">(</span><span class="i">token</span><span class="p">.</span><span class="i">getType</span><span class="p">());</span>
    <span class="i">left</span> <span class="o">=</span> <span class="i">infix</span><span class="p">.</span><span class="i">parse</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="i">left</span><span class="p">,</span> <span class="i">token</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="i">left</span><span class="p">;</span>
<span class="p">}</span></pre>
<p>That relies on a tiny helper function to get the precedence of the current
token or a default value if there&rsquo;s no infix parselet for the token:</p>
<pre class="highlight language-java"><span class="k">private</span> <span class="t">int</span> <span class="i">getPrecedence</span><span class="p">()</span> <span class="p">{</span>
  <span class="t">InfixParselet</span> <span class="i">parser</span> <span class="o">=</span> <span class="i">mInfixParselets</span><span class="p">.</span><span class="i">get</span><span class="p">(</span>
      <span class="i">lookAhead</span><span class="p">(</span><span class="n">0</span><span class="p">).</span><span class="i">getType</span><span class="p">());</span>
  <span class="k">if</span> <span class="p">(</span><span class="i">parser</span> <span class="o">!=</span> <span class="k">null</span><span class="p">)</span> <span class="k">return</span> <span class="i">parser</span><span class="p">.</span><span class="i">getPrecedence</span><span class="p">();</span>

  <span class="k">return</span> <span class="n">0</span><span class="p">;</span>
<span class="p">}</span></pre>
<p>And that&rsquo;s it. To wire precedence into Bantam&rsquo;s grammar, we set up a little
precedence table:</p>
<pre class="highlight language-java"><span class="k">public</span> <span class="k">class</span> <span class="t">Precedence</span> <span class="p">{</span>
  <span class="k">public</span> <span class="k">static</span> <span class="k">final</span> <span class="t">int</span> <span class="i">ASSIGNMENT</span>  <span class="o">=</span> <span class="n">1</span><span class="p">;</span>
  <span class="k">public</span> <span class="k">static</span> <span class="k">final</span> <span class="t">int</span> <span class="i">CONDITIONAL</span> <span class="o">=</span> <span class="n">2</span><span class="p">;</span>
  <span class="k">public</span> <span class="k">static</span> <span class="k">final</span> <span class="t">int</span> <span class="i">SUM</span>         <span class="o">=</span> <span class="n">3</span><span class="p">;</span>
  <span class="k">public</span> <span class="k">static</span> <span class="k">final</span> <span class="t">int</span> <span class="i">PRODUCT</span>     <span class="o">=</span> <span class="n">4</span><span class="p">;</span>
  <span class="k">public</span> <span class="k">static</span> <span class="k">final</span> <span class="t">int</span> <span class="i">EXPONENT</span>    <span class="o">=</span> <span class="n">5</span><span class="p">;</span>
  <span class="k">public</span> <span class="k">static</span> <span class="k">final</span> <span class="t">int</span> <span class="i">PREFIX</span>      <span class="o">=</span> <span class="n">6</span><span class="p">;</span>
  <span class="k">public</span> <span class="k">static</span> <span class="k">final</span> <span class="t">int</span> <span class="i">POSTFIX</span>     <span class="o">=</span> <span class="n">7</span><span class="p">;</span>
  <span class="k">public</span> <span class="k">static</span> <span class="k">final</span> <span class="t">int</span> <span class="i">CALL</span>        <span class="o">=</span> <span class="n">8</span><span class="p">;</span>
<span class="p">}</span></pre>
<p>To make our operators parse their operands with the correct precedence, they
pass an appropriate value back into <code>parseExpression()</code> when they call it
recursively. For example, the <a href="https://github.com/munificent/bantam/blob/master/src/com/stuffwithstuff/bantam/parselets/BinaryOperatorParselet.java">BinaryOperatorParselet</a> instance that handles
the <code>+</code> operator passes in <code>Precedence.SUM</code> when it parses its right-hand
operand.</p>
<p>Associativity is easy too. If an infix parselet calls <code>parseExpression()</code> with
the <em>same</em> precedence that it returns for its own <code>getPrecedence()</code> call, you
get left associativity. To be right-associative, it just needs to pass in <em>one
less</em> than that instead.</p>
<h2 id="go-forth-and-multiply"><a href="#go-forth-and-multiply">Go forth and multiply<span class="anchor">#go-forth-and-multiply</span></a></h2>
<p>I&rsquo;ve rewritten the <a href="https://github.com/munificent/magpie/blob/master/src/com/stuffwithstuff/magpie/parser/MagpieParser.java">parser for Magpie</a> using this and it worked
like a charm. I&rsquo;m also working on a JavaScript parser using this technique and
again it&rsquo;s been a great fit.</p>
<p>I Pratt parsers to be simple, terse, extensible (Magpie, for example, uses this
to <a href="/2011/02/13/extending-syntax-from-within-a-language/">let you extend its own syntax</a> at runtime), and easy to read. I&rsquo;m at
the point where I can&rsquo;t imagine writing a parser any other way. I never thought
I&rsquo;d say this, but parsers feel easy now.</p>
<p>To see for yourself, just take a look at <a href="https://github.com/munificent/bantam">the complete program</a>.</p><div class="update">
<p><em>Update 2022/05/14:</em> John Cardinal has
<a href="https://github.com/jfcardinal/BantamCs">ported the code to C#</a>.</p>
</div>
<div class="comments">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
      var disqus_shortname = 'journal-stuffwithstuff';
      var disqus_url = "https://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/";

      (function() {
          var dsq = document.createElement('script');
          dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</article>
<footer id="footer">
  <figure>
  <a href="/"><img src="/image/dogshot_square.jpg"></a>
  </figure>
  <p>Hi! I'm Bob Nystrom. (I'm the one with glasses, not the
    <a href="/2022/02/13/stupid-dog/">dog</a>.) I wrote <a href="https://gameprogrammingpatterns.com/">Game Programming Patterns</a> and
    <a href="https://craftinginterpreters.com">Crafting Interpreters</a>. I
    make electronic music under the name
    <a href="https://tinywir.es/">Tiny Wires</a>.</p>
  <p>I'm on <a href="https://mastodon.social/@munificent">Mastodon</a> and <a href="https://bsky.app/profile/stuffwithstuff.com">Bluesky</a>, or you can email me at <code>robert</code> at this site.</p>
  <p>I built this blog using a bespoke static site generator and wrote every single word myself. The source repo
  is <a href="https://github.com/munificent/journal">here</a>.</p>
  <div class="nav-second">
  </div>
  <p class="copyright">&copy; 2008-2025 Bob Nystrom</p>
</footer>
    </main>
  </body>
 </html>
